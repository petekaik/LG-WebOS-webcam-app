<!--
Copyright (c) 2024 LG Electronics Inc.

SPDX-License-Identifier: Apache-2.0
-->

<!DOCTYPE html>
<html>

<head>
	<title>Webcam Viewer</title>
	<style type="text/css">
		body {
			width: 100%;
			height: 100%;
			background-color: #202020;
			margin: 0;
			padding: 0;
			overflow: hidden;
			font-family: Arial, sans-serif;
			color: #FFFFFF;
		}

		.container {
			position: absolute;
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		.header {
			height: 60px;
			background-color: #101010;
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 0 20px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
			z-index: 10;
		}

		.header-left {
			display: flex;
			align-items: center;
			gap: 15px;
		}

		.app-title {
			font-size: 24px;
			font-weight: bold;
		}

		.header-right {
			display: flex;
			align-items: center;
		}

		.clock {
			position: absolute;
			top: 15px;
			left: 50%;
			transform: translateX(-50%);
			background-color: rgba(0, 0, 0, 0.7);
			padding: 5px 15px;
			border-radius: 5px;
			font-size: 20px;
			z-index: 11;
			color: #FFFFFF;
			display: block;
		}

		/* Hide header and clock when in fullscreen mode */
		.container.fullscreen-active .clock,
		.container.fullscreen-active .header {
			display: none;
		}

		.settings-button {
			background-color: transparent;
			border: none;
			color: #FFFFFF;
			cursor: pointer;
			font-size: 18px;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px;
			border-radius: 4px;
			transition: background-color 0.2s;
			margin-left: 20px;
		}

		.settings-button.focused {
			background-color: rgba(66, 133, 244, 0.6);
		}

		.settings-button:hover {
			background-color: rgba(255, 255, 255, 0.1);
		}

		/* Fixed grid layout to display proper thumbnails */
		.webcam-grid {
			display: flex;
			flex-wrap: wrap;
			justify-content: center;
			align-items: center;
			gap: 20px;
			padding: 20px;
			box-sizing: border-box;
			width: 100%;
			height: calc(100% - 60px); /* Subtract header height */
			max-width: 1920px; /* Max width for 4K TVs */
			margin: 0 auto;
		}

		/* Fixed container sizing for proper grid cells */
		.webcam-container {
			position: relative;
			width: calc(50% - 20px); /* Adjust width for 2 columns with gap */
			height: calc(50% - 20px); /* Adjust height for 2 rows with gap */
			max-width: 640px;
			max-height: 360px;
			background-color: #303030;
			overflow: hidden;
			border-radius: 8px;
			border: 2px solid transparent;
		}

		.webcam-container.focused {
			border: 2px solid #4285f4;
			box-shadow: 0 0 15px rgba(66, 133, 244, 0.8);
			transform: scale(1.02);
			transition: transform 0.2s ease;
			z-index: 2;
		}

		.webcam-feed {
			width: 100%;
			height: 100%;
			object-fit: cover;
			background-color: #000;
		}

		.webcam-label {
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 8px;
			text-align: center;
		}

		.fullscreen-mode {
			position: absolute;
			top: 0; /* Changed from 60px to 0 to use full screen height */
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #000000;
			z-index: 100;
			display: none;
		}

		.fullscreen-feed {
			width: 100%;
			height: 100%;
			object-fit: contain;
		}

		.log-box {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background-color: rgba(0, 0, 0, 0.8);
			border-radius: 8px;
			padding: 10px 20px;
			min-width: 300px;
			max-width: 80%;
			text-align: center;
			opacity: 0;
			transition: opacity 0.3s;
			z-index: 20;
		}

		.log-box.show {
			opacity: 1;
		}

		.navigation-hint {
			position: absolute;
			bottom: 10px;
			right: 10px;
			background-color: rgba(0, 0, 0, 0.6);
			padding: 10px;
			border-radius: 5px;
			font-size: 14px;
			color: #FFFFFF;
		}
		
		.stream-placeholder {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			text-align: center;
			background-color: #303030;
			color: #aaaaaa;
			padding: 20px;
		}
		
		.stream-placeholder-icon {
			font-size: 32px;
			margin-bottom: 10px;
		}
		
		.stream-placeholder-text {
			font-size: 14px;
			max-width: 80%;
		}

		/* Settings modal styling */
		.settings-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.7);
			z-index: 100;
			display: none;
			justify-content: center;
			align-items: center;
		}

		.settings-modal {
			width: 80%;
			max-width: 800px;
			max-height: 80vh;
			background-color: #303030;
			border-radius: 8px;
			box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
			overflow: hidden;
			display: flex;
			flex-direction: column;
		}

		.settings-header {
			background-color: #202020;
			padding: 15px 20px;
			display: flex;
			justify-content: space-between;
			align-items: center;
			border-bottom: 1px solid #404040;
		}

		.settings-title {
			font-size: 22px;
			font-weight: bold;
		}

		.settings-close {
			background: transparent;
			border: none;
			color: #FFFFFF;
			font-size: 22px;
			cursor: pointer;
		}

		.settings-content {
			flex: 1;
			padding: 20px;
			overflow-y: auto;
		}

		.settings-section {
			margin-bottom: 25px;
		}

		.settings-section-title {
			font-size: 18px;
			font-weight: bold;
			margin-bottom: 15px;
			border-bottom: 1px solid #404040;
			padding-bottom: 5px;
		}

		.webcam-list {
			display: flex;
			flex-direction: column;
			gap: 15px;
		}

		.webcam-item {
			background-color: #252525;
			border-radius: 6px;
			padding: 15px;
			display: flex;
			justify-content: space-between;
			align-items: center;
			transition: background-color 0.2s;
		}

		.webcam-item.focused {
			background-color: #3a3a3a;
			box-shadow: 0 0 0 2px #4285f4;
		}

		.webcam-item-info {
			flex: 1;
		}

		.webcam-item-name {
			font-weight: bold;
			margin-bottom: 5px;
		}

		.webcam-item-url {
			font-size: 12px;
			color: #aaaaaa;
			word-break: break-all;
		}

		.webcam-item-actions {
			display: flex;
			gap: 10px;
		}

		.action-button {
			background-color: transparent;
			border: 1px solid #505050;
			color: #FFFFFF;
			padding: 6px 10px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.2s;
		}

		.action-button:hover, .action-button.focused {
			background-color: rgba(66, 133, 244, 0.2);
			border-color: #4285f4;
		}

		.action-button.delete {
			border-color: #ff4d4d;
			color: #ff4d4d;
		}

		.action-button.delete:hover, .action-button.delete.focused {
			background-color: rgba(255, 77, 77, 0.2);
		}

		.add-webcam-form {
			background-color: #252525;
			border-radius: 6px;
			padding: 15px;
		}

		.form-group {
			margin-bottom: 15px;
		}

		.form-group label {
			display: block;
			margin-bottom: 5px;
			font-size: 14px;
		}

		.form-control {
			width: 100%;
			padding: 10px;
			background-color: #404040;
			border: 1px solid #505050;
			color: #FFFFFF;
			border-radius: 4px;
			font-size: 16px;
			box-sizing: border-box;
		}

		.form-control.focused {
			border-color: #4285f4;
			box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.4);
		}

		.form-buttons {
			display: flex;
			justify-content: flex-end;
			gap: 10px;
			margin-top: 20px;
		}

		.settings-footer {
			background-color: #252525;
			padding: 15px 20px;
			display: flex;
			justify-content: flex-end;
			gap: 10px;
			border-top: 1px solid #404040;
		}
		
		/* Splash screen styling */
		.splash-screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: #101010;
			z-index: 1000;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			transition: opacity 0.5s ease-in-out;
		}
		
		.splash-logo {
			font-size: 42px;
			font-weight: bold;
			color: #FFFFFF;
			margin-bottom: 20px;
			text-align: center;
		}
		
		.splash-spinner {
			width: 60px;
			height: 60px;
			border: 5px solid rgba(255, 255, 255, 0.3);
			border-radius: 50%;
			border-top-color: #FFFFFF;
			animation: spin 1s ease-in-out infinite;
		}
		
		@keyframes spin {
			to { transform: rotate(360deg); }
		}
		
		.splash-message {
			margin-top: 20px;
			font-size: 18px;
			color: #CCCCCC;
		}
		
		.hidden {
			opacity: 0;
			pointer-events: none;
		}

		/* General Styles */
		body {
			margin: 0;
			padding: 0;
			background-color: #000;
			color: #fff;
			font-family: Arial, sans-serif;
			overflow: hidden;
		}

		/* Grid Layout */
		.video-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			grid-gap: 10px;
			padding: 10px;
			height: calc(100vh - 60px);
		}

		/* Settings Panel */
		.settings-menu {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: rgba(0, 0, 0, 0.9);
			border: 1px solid #444;
			border-radius: 10px;
			padding: 20px;
			width: 60%;
			max-height: 80%;
			overflow-y: auto;
			z-index: 1000;
		}

		.hidden {
			display: none;
		}

		.settings-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
			border-bottom: 1px solid #444;
			padding-bottom: 10px;
		}

		.settings-section {
			margin-bottom: 20px;
		}

		.form-group {
			margin-bottom: 15px;
		}

		.form-group label {
			display: block;
			margin-bottom: 5px;
		}

		.form-group input[type="text"],
		.form-group select {
			width: 100%;
			padding: 10px;
			background-color: #333;
			border: 1px solid #555;
			color: #fff;
			border-radius: 5px;
		}

		.form-group input[type="checkbox"] {
			width: 20px;
			height: 20px;
			vertical-align: middle;
		}

		.settings-buttons {
			display: flex;
			justify-content: flex-end;
			gap: 10px;
			margin-top: 20px;
		}

		.btn {
			padding: 10px 15px;
			background-color: #1d86e2;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			font-size: 16px;
		}

		.btn-close {
			background-color: transparent;
			font-weight: bold;
			font-size: 20px;
		}

		.btn:hover, .btn:focus {
			background-color: #0e6ab7;
		}

		.btn-close:hover, .btn-close:focus {
			color: #1d86e2;
			background-color: transparent;
		}

		.webcam-list {
			margin-bottom: 15px;
		}

		.webcam-item {
			padding: 10px;
			background-color: #333;
			margin-bottom: 5px;
			border-radius: 5px;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.webcam-item-selected {
			background-color: #1d86e2;
		}

		.webcam-item-name {
			font-weight: bold;
		}

		/* Video Container */
		.video-container {
			position: relative;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}

		.video-container video {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.video-container.selected {
			border: 3px solid #1d86e2;
		}

		.video-overlay {
			position: absolute;
			bottom: 10px;
			left: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 5px 10px;
			border-radius: 5px;
		}

		/* Clock */
		.clock {
			position: absolute;
			top: 15px;
			left: 50%;
			transform: translateX(-50%);
			background-color: rgba(0, 0, 0, 0.7);
			padding: 5px 15px;
			border-radius: 5px;
			font-size: 20px;
			z-index: 11;
			color: #FFFFFF;
			display: block;
		}

		.container.fullscreen-active .clock {
			display: none;
		}

		/* Log Box */
		.log-container {
			position: absolute;
			bottom: 10px;
			right: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 5px;
			max-width: 300px;
			max-height: 200px;
			overflow-y: auto;
			opacity: 0;
			transition: opacity 0.3s ease;
		}

		.log-container.visible {
			opacity: 1;
		}

		.log-entry {
			margin-bottom: 5px;
			font-size: 14px;
		}

		.log-entry.error {
			color: #ff5252;
		}

		.log-entry.info {
			color: #4caf50;
		}

		/* Network Status Indicator */
		.network-status {
			position: absolute;
			top: 10px;
			left: 10px;
			display: flex;
			align-items: center;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 5px 10px;
			border-radius: 5px;
		}

		.network-indicator {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			margin-right: 8px;
		}

		.network-online {
			background-color: #4caf50;
		}

		.network-offline {
			background-color: #ff5252;
		}

		/* Fullscreen mode */
		.fullscreen-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 900;
			background-color: #000;
		}

		.fullscreen-container video {
			width: 100%;
			height: 100%;
			object-fit: contain;
		}

		.fullscreen-overlay {
			position: absolute;
			bottom: 20px;
			left: 20px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 5px;
			font-size: 24px;
		}

		/* Media queries for responsive design */
		@media (max-width: 768px) {
			.video-grid {
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			}
		}

        /* Grid Layout Settings */
        #custom-grid-options {
            margin-top: 15px;
        }
        
        #custom-grid-options input {
            width: 50px;
            margin-right: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-control {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        /* Network Status Indicator */
        #network-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            color: white;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .status-online {
            background-color: #2ecc71;
        }
        
        .status-offline {
            background-color: #e74c3c;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
		/* Base styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'LG Smart', 'Roboto', sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* Network status indicator styles */
        #network-status {
            display: flex;
            align-items: center;
            margin-left: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }
        
        .status-online {
            background-color: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }
        
        .status-offline {
            background-color: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        /* Grid settings specific styles */
        .form-group {
            margin-bottom: 15px;
        }
        
        #custom-grid-options {
            margin-top: 5px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        /* Confirmation dialog styles */
        .confirmation-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .confirmation-dialog-content {
            background-color: #303030;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        .confirmation-dialog-header {
            background-color: #252525;
            padding: 15px 20px;
            font-size: 20px;
            font-weight: bold;
        }
        
        .confirmation-dialog-body {
            padding: 20px;
            font-size: 16px;
            text-align: center;
        }
        
        .confirmation-dialog-footer {
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            background-color: #252525;
        }
        
        .hidden {
            display: none;
        }
	</style>
</head>

<script src="webOSTVjs-1.2.10/webOSTV.js" charset="utf-8"></script>
<!-- Remove the dev script to avoid conflicts -->
<script type="text/javascript">
	// Default webcam configuration
    const defaultWebcamConfig = [
        { id: 1, name: 'Front Door', url: 'http://192.168.1.20:8888/etupiha/index.m3u8', enabled: true },
        { id: 2, name: 'Back Yard', url: 'http://192.168.1.20:8888/takapiha/index.m3u8', enabled: true },
        { id: 3, name: 'Living Room', url: 'http://192.168.1.102:8080/video', enabled: false },
        { id: 4, name: 'Garage', url: 'http://192.168.1.103:8080/video', enabled: false }
    ];

    // Default layout settings
    const defaultLayoutSettings = {
        gridRows: 2,
        gridColumns: 2,
        autoLayout: true,
        showLabels: true,
        refreshInterval: 0 // 0 means no refresh, value in seconds
    };

    // Global variables
    let webcamConfig = [];
    let layoutSettings = {};
    let selectedWebcam = null;
    let isFullscreen = false;
	let currentFocusedCam = null;
	let isFullscreenMode = false;
	let activeFullscreenCam = null;
	let isSettingsOpen = false;
	let clockInterval;
	let appLoaded = false;
	let loadedStreams = 0;
	let attemptedStreams = 0; // Added counter for attempted loads
	let networkStatus = "online";

	// Function containing WebOS-dependent initialization
	function initializeApp() {
		try {
			logMessage("webOS is ready. Initializing App Components...");
			console.log("[Debug] initializeApp called."); // Debug log

			// Initialize components that depend on webOS or DOM elements
			initializeClock();
			console.log("[Debug] Clock initialized."); // Debug log
			initNetworkMonitoring();  // Initialize network monitoring
			console.log("[Debug] Network monitoring initialized."); // Debug log
			loadWebcams(); // Starts loading streams asynchronously
			console.log("[Debug] loadWebcams called."); // Debug log
			setupNavigation();
			console.log("[Debug] Navigation setup."); // Debug log

			// Initial check after 2 seconds minimum display time (relative to app init)
			console.log("[Debug] Setting 2s checkAllResourcesLoaded timer..."); // Debug log
			setTimeout(function() {
				console.log("[Debug] 2s timer fired - calling checkAllResourcesLoaded"); // Debug log
				checkAllResourcesLoaded();
			}, 2000);

		} catch (error) {
			logMessage("Error during app initialization: " + error.message);
			console.error("Error in initializeApp:", error);
			// Attempt to hide splash screen immediately if an error occurs here
			console.log("[Debug] Error in initializeApp - attempting immediate hideSplashScreen"); // Debug log
			hideSplashScreen();
		}
	}

	// Initialize the application when DOM is loaded
	document.addEventListener('DOMContentLoaded', function() {
		try {
			console.log("[Debug] DOMContentLoaded start");

			showSplashScreen();
			console.log("[Debug] Splash screen shown");

			loadSettings();
			console.log("[Debug] Settings loaded");

			 // Simpler approach to WebOS initialization - check if object exists and use it
			if (typeof webOS !== 'undefined') {
				console.log("[Debug] webOS object found. Setting up initialization...");
				
				// Simple initialization - either attach listener or initialize directly
				if (typeof webOS.on === 'function') {
					// Modern versions with 'ready' event
					webOS.on('ready', function() {
						console.log("[Debug] webOS ready event fired");
						initializeApp();
					});
				} else {
					// Older versions may not have 'ready' event, initialize directly
					console.log("[Debug] Using direct initialization for older webOS");
					setTimeout(function() {
						initializeApp();
					}, 500); // Small delay to let WebOS APIs become available
				}
			} else {
				// webOS object doesn't exist - critical issue
				console.error("[Debug] CRITICAL: webOS object not found at DOMContentLoaded!");
				logMessage("Error: webOS environment not detected!");
				const splashMessage = document.getElementById('splash-message');
				if (splashMessage) {
					splashMessage.textContent = "webOS API Not Available";
					splashMessage.style.color = 'red';
				}
			}

			// Fallback timer remains crucial
			console.log("[Debug] Setting 7s fallback hideSplashScreen timer...");
			setTimeout(function() {
				console.log("[Debug] 7s fallback timer fired - calling hideSplashScreen");
				hideSplashScreen(); // Force hide if still visible
			}, 7000);

			console.log("[Debug] DOMContentLoaded end");

		} catch (error) {
			console.error("[Debug] CRITICAL ERROR in DOMContentLoaded:", error);
			const splashMessage = document.getElementById('splash-message');
			if (splashMessage) {
				splashMessage.textContent = "Initialization Error!";
				splashMessage.style.color = 'red';
				}
			}
		});

	// Load settings from localStorage
	function loadSettings() {
		try {
			const savedWebcams = localStorage.getItem('webcamConfig');
			webcamConfig = savedWebcams ? JSON.parse(savedWebcams) : defaultWebcamConfig;
			
			const savedLayoutSettings = localStorage.getItem('layoutSettings');
			if (savedLayoutSettings) {
				layoutSettings = JSON.parse(savedLayoutSettings);
				// Ensure all required properties exist with defaults if missing
				layoutSettings.gridRows = layoutSettings.gridRows || defaultLayoutSettings.gridRows;
				layoutSettings.gridColumns = layoutSettings.gridColumns || defaultLayoutSettings.gridColumns;
				layoutSettings.autoLayout = typeof layoutSettings.autoLayout === 'boolean' ? 
					layoutSettings.autoLayout : defaultLayoutSettings.autoLayout;
				layoutSettings.showLabels = typeof layoutSettings.showLabels === 'boolean' ? 
					layoutSettings.showLabels : defaultLayoutSettings.showLabels;
				layoutSettings.refreshInterval = layoutSettings.refreshInterval || defaultLayoutSettings.refreshInterval;
			} else {
				layoutSettings = JSON.parse(JSON.stringify(defaultLayoutSettings)); // Deep copy
			}
			
			logMessage("Settings loaded successfully");
			console.log("Layout settings loaded:", layoutSettings); // Debug log
		} catch (error) {
			logMessage(`Error loading settings: ${error.message}`);
			console.error(`Error loading settings: ${error.message}`);
			webcamConfig = defaultWebcamConfig;
			layoutSettings = JSON.parse(JSON.stringify(defaultLayoutSettings)); // Deep copy
		}
	}

	// Save settings to local storage
	function saveSettings() {
		try {
			localStorage.setItem('webcamConfig', JSON.stringify(webcamConfig));
			logMessage("Settings saved successfully");
			return true;
		} catch (error) {
			logMessage("Error saving settings");
			console.error("Settings save error:", error);
			return false;
		}
	}
	
	// Show the splash screen
	function showSplashScreen() {
		const splashScreen = document.getElementById('splash-screen');
		splashScreen.classList.remove('hidden');
	}
	
	// Hide the splash screen
	function hideSplashScreen() {
		console.log("[Debug] hideSplashScreen called. appLoaded:", appLoaded); // Debug log
		if (appLoaded) {
			console.log("[Debug] hideSplashScreen - already loaded, returning."); // Debug log
			return; // Avoid hiding multiple times
		}

		const splashScreen = document.getElementById('splash-screen');
		if (splashScreen) {
			console.log("[Debug] Hiding splash screen element."); // Debug log
			splashScreen.classList.add('hidden');
			appLoaded = true; // Set flag *after* successfully finding element

			// Remove splash screen from DOM after transition
			setTimeout(function() {
				if (splashScreen) { // Check if splashScreen still exists
					console.log("[Debug] Removing splash screen element from DOM."); // Debug log
					splashScreen.style.display = 'none';
				}
			}, 500);

			logMessage("Webcam app initialized");
			console.log("[Debug] Webcam app initialized message logged."); // Debug log
			// Apply grid layout *after* splash screen is hidden
			applyGridLayout();
		} else {
			console.error("[Debug] hideSplashScreen - splash-screen element not found!"); // Debug log
			// If splash screen element isn't found, we might be in a weird state,
			// but set appLoaded anyway to prevent repeated attempts.
			appLoaded = true;
		}
	}
	
	// Check if all resources have loaded
	function checkAllResourcesLoaded() {
		// Hide splash screen if:
		// 1. No webcams are configured OR
		// 2. All configured webcams have been attempted (loaded or failed)
		if (!appLoaded && (webcamConfig.length === 0 || attemptedStreams === webcamConfig.length)) {
			hideSplashScreen();
		}
		// Otherwise, wait for more streams to load/fail or the final timeout
	}

	// Initialize clock display
	function initializeClock() {
		 // webOS object check removed - this function is now called only after webOS is ready
		logMessage("Initializing clock...");
		updateClock(); // Initial call
		clockInterval = setInterval(updateClock, 1000);
	}

	// Update clock with current time
	function updateClock() {
		// Keep the check here in case the service becomes unavailable later
		if (typeof webOS === 'undefined' || !webOS.service) {
			logMessage("webOS service lost.");
			console.error("webOS service lost during updateClock.");
			if (clockInterval) clearInterval(clockInterval); // Stop trying
			const clockElement = document.getElementById('clock');
			if (clockElement) clockElement.textContent = "Clock Lost";
			return;
		}

		webOS.service.request("luna://com.palm.systemservice", {
			method: "clock/getTime",
			parameters: {},
			onSuccess: function (args) {
				try {
					const clockElement = document.getElementById('clock');
					if (clockElement) {
						const date = new Date(args.utc * 1000);
						
						// Format time manually to avoid locale-specific prefixes
						let hours = date.getHours();
						let minutes = date.getMinutes();
						
						// Pad with leading zeros if needed
						hours = hours < 10 ? '0' + hours : hours;
						minutes = minutes < 10 ? '0' + minutes : minutes;
						
						// Create simple time string (HH:MM)
						const timeString = hours + ':' + minutes;
						
						clockElement.textContent = timeString;
					} else {
						console.error("Clock element not found in onSuccess.");
					}
				} catch (error) {
					logMessage("Error processing time.");
					console.error("Error in clock onSuccess:", error);
				}
			},
			onFailure: function (args) {
				try {
					logMessage("Failed to get time: " + args.errorText);
					console.error("Failed to get time:", args);
					const clockElement = document.getElementById('clock');
					if (clockElement) {
						clockElement.textContent = "Time Error";
					}
				} catch (error) {
					logMessage("Error handling clock failure.");
					console.error("Error in clock onFailure:", error);
				}
			}
		});
	}

	// Load webcam feeds
	function loadWebcams() {
		const webcamGrid = document.getElementById('webcam-grid');
		webcamGrid.innerHTML = ''; // Clear any existing content
		loadedStreams = 0; // Reset counters
		attemptedStreams = 0; // Reset counters
		
		// Filter to only include enabled webcams
		const enabledWebcams = webcamConfig.filter(cam => cam.enabled);
		
		// Handle case with no enabled webcams
		if (enabledWebcams.length === 0) {
			logMessage("No enabled webcams found. Enable webcams in Settings.");
			// If no webcams, trigger splash screen hide check immediately
			checkAllResourcesLoaded();
			// Apply layout for the empty grid state
			applyGridLayout();
			return; // Exit function early
		}

		enabledWebcams.forEach((cam, index) => {
			const container = document.createElement('div');
			container.className = 'webcam-container';
			container.setAttribute('data-cam-id', cam.id);
			container.id = `cam-container-${cam.id}`;

			// If this is the first camera, set it as focused
			if (index === 0) {
				container.className += ' focused';
				currentFocusedCam = cam.id;
			}

			// Create a video element for the stream
			const video = document.createElement('video');
			video.className = 'webcam-feed';
			video.id = `video-${cam.id}`;
			video.muted = true; // Mute video in grid view as per FR-1.3
			video.autoplay = true;
			video.playsInline = true;
			video.setAttribute('playsinline', '');

			// Update splash screen message
			document.getElementById('splash-message').textContent = `Loading ${cam.name} feed...`;

			// Handle video source with error handling
			try {
				video.src = cam.url;

				// Add event handlers for video
				video.onerror = function(e) {
					handleVideoError(container, cam);
					attemptedStreams++; // Increment attempted count
					checkAllResourcesLoaded(); // Check if done loading all streams
				};

				video.onloadstart = function() {
					logMessage(`Loading ${cam.name} feed...`);
				};

				video.oncanplay = function() {
					logMessage(`${cam.name} feed ready`);
					loadedStreams++; // Increment loaded count
					attemptedStreams++; // Increment attempted count
					checkAllResourcesLoaded(); // Check if done loading all streams
				};
			} catch (error) {
				handleVideoError(container, cam);
				attemptedStreams++; // Increment attempted count on setup error
				checkAllResourcesLoaded(); // Check if done loading all streams
			}

			const label = document.createElement('div');
			label.className = 'webcam-label';
			label.textContent = cam.name;

			container.appendChild(video);
			container.appendChild(label);
			webcamGrid.appendChild(container);

			// Add click event for switching to full-screen mode
			container.addEventListener('click', function() {
				enterFullscreenMode(cam.id);
			});
		});
	}

	// Handle video loading errors
	function handleVideoError(container, cam) {
		logMessage(`Error loading ${cam.name} feed`);
		
		// Remove video element
		const video = container.querySelector('video');
		if (video) {
			video.remove();
		}
		
		// Add placeholder with friendly message instead of just an error
		const placeholder = document.createElement('div');
		placeholder.className = 'stream-placeholder';
		
		const icon = document.createElement('div');
		icon.className = 'stream-placeholder-icon';
		icon.innerHTML = '📷';
		
		const message = document.createElement('div');
		message.className = 'stream-placeholder-text';
		message.innerHTML = `<strong>${cam.name}</strong> stream is currently unavailable.<br>Please check your network connection or camera status.`;		
		placeholder.appendChild(icon);
		placeholder.appendChild(message);
		container.appendChild(placeholder);
	}

	// Set up navigation with remote control
	function setupNavigation() {
		console.log("Setting up navigation listeners...");
		document.addEventListener('keydown', function(event) {
			if (isSettingsOpen) {
				handleSettingsNavigation(event);
			} else if (isFullscreenMode) {
				handleFullscreenNavigation(event);
			} else {
				handleGridNavigation(event);
			}
		});

		const settingsButton = document.getElementById('settings-button');
		if (settingsButton) {
			settingsButton.addEventListener('click', function() {
				openSettingsMenu();
			});
		} else {
			console.error("Settings button not found during setupNavigation");
		}
	}

	// Handle navigation in grid view
	function handleGridNavigation(event) {
		// Basic navigation implementation
		switch (event.keyCode) {
			case 37: // LEFT
				navigateGrid('left');
				break;
			case 38: // UP
				navigateGrid('up');
				break;
			case 39: // RIGHT
				navigateGrid('right');
				break;
			case 40: // DOWN
				navigateGrid('down');
				break;
			case 13: // ENTER
				if (currentFocusedCam !== null) {
					enterFullscreenMode(currentFocusedCam);
				}
				break;
			case 461: // BACK
			case 27:  // ESC
				// Exit app or handle back action
				break;
		}
	}

	// Navigate between cameras in the grid
	function navigateGrid(direction) {
			// Get all visible webcam containers
			const containers = document.querySelectorAll('.webcam-container');
			if (containers.length === 0) return;
			
			// Find the currently focused container index
			let currentIndex = -1;
			containers.forEach((container, index) => {
				if (container.classList.contains('focused')) {
					currentIndex = index;
				}
			});
			
			// If no focused container, focus the first one
			if (currentIndex === -1) {
				containers[0].classList.add('focused');
				currentFocusedCam = parseInt(containers[0].getAttribute('data-cam-id'));
				return;
			}
			
			// Determine grid dimensions (from layout settings or auto-calculate)
			let cols = layoutSettings.autoLayout ? 
				Math.ceil(Math.sqrt(containers.length)) : layoutSettings.gridColumns;
			
			// Ensure we have a valid column count
			if (!cols || cols <= 0) cols = 2; // Default fallback
			
			// Calculate current row and column position
			const currentRow = Math.floor(currentIndex / cols);
			const currentCol = currentIndex % cols;
			
			// Calculate target position based on direction
			let targetRow = currentRow;
			let targetCol = currentCol;
			let targetIndex = currentIndex;
			
			switch (direction) {
				case 'up':
					targetRow = (currentRow - 1 + Math.ceil(containers.length / cols)) % Math.ceil(containers.length / cols);
					break;
				case 'down':
					targetRow = (currentRow + 1) % Math.ceil(containers.length / cols);
					break;
				case 'left':
					targetCol = (currentCol - 1 + cols) % cols;
					// Make sure we don't go out of bounds
					if (targetRow * cols + targetCol >= containers.length) {
						// Wrap to the last item in the previous row
						targetRow = targetRow - 1;
						targetCol = cols - 1;
						// If we're at the top row, go to the last row
						if (targetRow < 0) {
							targetRow = Math.ceil(containers.length / cols) - 1;
							// Adjust column if the last row isn't full
							if (targetRow * cols + targetCol >= containers.length) {
								targetCol = (containers.length - 1) % cols;
							}
						}
					}
					break;
				case 'right':
					targetCol = (currentCol + 1) % cols;
					// If we're at the end of a row, go to the next row
					if (targetRow * cols + targetCol >= containers.length) {
						targetRow = (targetRow + 1) % Math.ceil(containers.length / cols);
						targetCol = 0;
					}
					break;
			}
			
			// Calculate the new target index
			targetIndex = targetRow * cols + targetCol;
			
			// Ensure the target index is valid
			if (targetIndex >= containers.length) {
				targetIndex = containers.length - 1;
			}
			
			// Remove focus from the current container
			containers[currentIndex].classList.remove('focused');
			
			// Add focus to the target container
			containers[targetIndex].classList.add('focused');
			
			// Update the current focused cam
			currentFocusedCam = parseInt(containers[targetIndex].getAttribute('data-cam-id'));
			
			// Log the navigation action
			logMessage(`Navigation: ${direction}, focused cam ${currentFocusedCam}`);
		}

	// Handle navigation in fullscreen mode
	function handleFullscreenNavigation(event) {
		switch (event.keyCode) {
			case 38: // UP
				navigateFullscreen('prev');
				break;
			case 40: // DOWN
				navigateFullscreen('next');
				break;
			case 461: // BACK (WebOS specific)
			case 27:  // ESC (standard browsers)
			case 37:  // LEFT (for intuitive back navigation)
				exitFullscreenMode();
				break;
			case 13: // ENTER/OK
				// You could add additional fullscreen actions here
				break;
		}
	}

	// Navigate between cameras in fullscreen mode
	function navigateFullscreen(direction) {
		// Get list of enabled webcams
		const enabledCams = webcamConfig.filter(cam => cam.enabled);
		if (enabledCams.length <= 1) return; // Nothing to navigate if only one camera
		
		// Find current cam index
		let currentIndex = enabledCams.findIndex(cam => cam.id === activeFullscreenCam);
		if (currentIndex === -1) currentIndex = 0;
		
		// Calculate target index based on direction
		let targetIndex;
		if (direction === 'next') {
			targetIndex = (currentIndex + 1) % enabledCams.length;
		} else { // 'prev'
			targetIndex = (currentIndex - 1 + enabledCams.length) % enabledCams.length;
		}
		
		// Switch to the target camera
		const targetCam = enabledCams[targetIndex];
		enterFullscreenMode(targetCam.id);
		
		logMessage(`Fullscreen navigation: ${direction}, now showing ${targetCam.name}`);
	}

	// Enter fullscreen mode for a specific camera
	function enterFullscreenMode(camId) {
		const cam = webcamConfig.find(c => c.id === parseInt(camId));
		if (!cam) {
			logMessage("Error: Camera not found");
			return;
		}

		// Store for navigation
		isFullscreenMode = true;
		activeFullscreenCam = parseInt(camId);
		currentFocusedCam = parseInt(camId);

		// Get elements
		const container = document.querySelector('.container');
		const fullscreenMode = document.getElementById('fullscreen-mode');
		const fullscreenVideo = document.getElementById('fullscreen-video');
		const fullscreenLabel = document.getElementById('fullscreen-label');

		// Add class to container to hide clock via CSS
		if (container) {
			container.classList.add('fullscreen-active');
		}

		// Set up video
		fullscreenVideo.src = cam.url;
		fullscreenVideo.muted = false; // Enable audio in fullscreen (FR-1.4)
		fullscreenVideo.play();
		
		// Set up label
		if (fullscreenLabel) {
			fullscreenLabel.textContent = cam.name;
		}
		
		// Show fullscreen container
		if (fullscreenMode) {
			fullscreenMode.style.display = 'block';
		}
		
		logMessage(`Fullscreen: ${cam.name}`);
	}

	// Exit fullscreen mode
	function exitFullscreenMode() {
		// Get elements
		const container = document.querySelector('.container');
		const fullscreenMode = document.getElementById('fullscreen-mode');
		const fullscreenVideo = document.getElementById('fullscreen-video');

		// Remove class from container to show clock again
		if (container) {
			container.classList.remove('fullscreen-active');
		}

		// Stop video playback and release resources
		if (fullscreenVideo) {
			fullscreenVideo.pause();
			fullscreenVideo.src = '';
		}

		// Hide the fullscreen container
		if (fullscreenMode) {
			fullscreenMode.style.display = 'none';
		}

		// Reset state
		isFullscreenMode = false;
		activeFullscreenCam = null;
		
		logMessage("Exited fullscreen mode");
	}

	// Handle navigation in settings menu
	function handleSettingsNavigation(event) {
		// This will be implemented based on the active settings mode
		// (list, add, edit, grid layout)
		switch (event.keyCode) {
			case 461: // BACK
			case 27:  // ESC
				closeSettingsMenu();
				break;
			// Other key handling will depend on the active settings mode
		}
	}

	// ----- SETTINGS MENU FUNCTIONS -----

	// Open settings menu
	function openSettingsMenu() {
		isSettingsOpen = true;
		const settingsOverlay = document.getElementById('settings-overlay');
		settingsOverlay.style.display = 'flex';

		// Reset to list mode
		showSettingsMode('list');

		logMessage("Settings menu opened");
	}

	// Close settings menu
	function closeSettingsMenu() {
		isSettingsOpen = false;
		const settingsOverlay = document.getElementById('settings-overlay');
		settingsOverlay.style.display = 'none';
		logMessage("Settings closed");
	}

	// Show specific settings mode and hide others
	function showSettingsMode(mode) {
		console.log(`Showing settings mode: ${mode}`); // Debug logging
		
		// Hide all modes first
		const listMode = document.getElementById('settings-list-mode');
		const addMode = document.getElementById('settings-add-mode');
		const editMode = document.getElementById('settings-edit-mode');
		const gridLayoutMode = document.getElementById('settings-grid-layout-mode');
		
		if (listMode) listMode.classList.add('hidden');
		if (addMode) addMode.classList.add('hidden');
		if (editMode) editMode.classList.add('hidden');
		if (gridLayoutMode) gridLayoutMode.classList.add('hidden');

		// Handle different mode names consistently
		let targetMode;
		switch(mode) {
			case 'list':
				targetMode = listMode;
				break;
			case 'add':
			case 'add-mode':
				targetMode = addMode;
				break;
			case 'edit':
			case 'edit-mode':
				targetMode = editMode;
				break;
			case 'grid':
			case 'grid-layout':
			case 'grid-layout-mode':
				targetMode = gridLayoutMode;
				break;
			default:
				console.error(`Unknown settings mode: ${mode}`);
				targetMode = listMode; // Default to list mode
				break;
		}

		// Show the requested mode
		if (targetMode) {
			targetMode.classList.remove('hidden');
			console.log(`Mode ${mode} displayed successfully`);
		} else {
			console.error(`Target element for mode ${mode} not found`);
		}

		// Update content based on the mode
		if (mode === 'list') {
			populateWebcamList();
		} else if (mode.includes('grid')) {
			populateGridLayoutSettings();
		}
	}

	// Populate webcam list in settings
	function populateWebcamList() {
		const webcamList = document.getElementById('settings-webcam-list');
		webcamList.innerHTML = '';

		webcamConfig.forEach((cam) => {
			const item = document.createElement('div');
			item.className = 'webcam-item';
			item.dataset.camId = cam.id;

			const info = document.createElement('div');
			info.className = 'webcam-item-info';
			
			const nameElem = document.createElement('div');
			nameElem.className = 'webcam-item-name';
			nameElem.textContent = cam.name;
			
			const urlElem = document.createElement('div');
			urlElem.className = 'webcam-item-url';
			urlElem.textContent = cam.url;
			
			info.appendChild(nameElem);
			info.appendChild(urlElem);
			
			const actions = document.createElement('div');
			actions.className = 'webcam-item-actions';
			
			const enabledLabel = document.createElement('div');
			enabledLabel.className = 'webcam-enabled-status';
			enabledLabel.textContent = cam.enabled ? 'Enabled' : 'Disabled';
			enabledLabel.style.color = cam.enabled ? '#4caf50' : '#ff5252';
			
			const editButton = document.createElement('button');
			editButton.className = 'action-button';
			editButton.textContent = 'Edit';
			editButton.onclick = () => openEditMode(cam.id);
			
			const deleteButton = document.createElement('button');
			deleteButton.className = 'action-button delete';
			deleteButton.textContent = 'Delete';
			deleteButton.onclick = () => deleteWebcam(cam.id);
			
			actions.appendChild(enabledLabel);
			actions.appendChild(editButton);
			actions.appendChild(deleteButton);
			
			item.appendChild(info);
			item.appendChild(actions);
			webcamList.appendChild(item);
		});

		// Add event listeners for list navigation
		setupWebcamListNavigation();

		// Add button click handlers
		document.getElementById('add-webcam-btn').onclick = () => openAddMode();
		document.getElementById('edit-layout-btn').onclick = () => showSettingsMode('grid-layout-mode');
		document.getElementById('cancel-settings-btn').onclick = closeSettingsMenu;
	}

	// Setup navigation for webcam list
	function setupWebcamListNavigation() {
			// Simple implementation for 5-way navigation of the webcam list
			// Set up key navigation between webcam items and buttons
			const webcamItems = document.querySelectorAll('.webcam-item');
			const buttons = document.querySelectorAll('#settings-list-mode .btn');
			
			// We'll implement focus-based navigation between list items in a future update
			// This will replace the implementation that was incorrectly switching to edit mode
			
			// For now, we just ensure buttons are properly clickable
			buttons.forEach(button => {
				// Make sure button is clickable via enter key when focused
				button.addEventListener('keydown', function(event) {
					if (event.keyCode === 13) { // Enter key
						this.click();
					}
				});
			});
		}

	// Save edited webcam
	function saveEditedWebcam() {
		const idValue = document.getElementById('edit-webcam-id').value;
		const id = parseInt(idValue);
		const name = document.getElementById('edit-webcam-name').value.trim();
		const url = document.getElementById('edit-webcam-url').value.trim();
		const enabled = document.getElementById('edit-webcam-enabled').checked;
		
		if (!name || !url) {
			logMessage("Please enter both name and URL");
			return;
		}
		
		// Find and update the webcam
		const camIndex = webcamConfig.findIndex(c => c.id === id);
		if (camIndex !== -1) {
			webcamConfig[camIndex] = {
				id: id,
				name: name,
				url: url,
				enabled: enabled
			};
			
			// Save to localStorage
			saveSettings();
			
			// Return to list mode
			showSettingsMode('list');
			
			logMessage(`Updated webcam: ${name}`);
			
			// Reload webcams if app is already loaded
			if (appLoaded) {
				loadWebcams();
			}
		} else {
			logMessage("Error: Could not find webcam to update");
		}
	}

	// Delete webcam
	function deleteWebcam(camId) {
		// Find webcam to get name for confirmation
		const camIndex = webcamConfig.findIndex(c => c.id === parseInt(camId));
		if (camIndex === -1) {
			logMessage("Error: Webcam not found");
			return;
		}
		
		const cam = webcamConfig[camIndex];
		showDeleteConfirmation(camId, cam.name);
	}
	
	// Show delete confirmation dialog
	function showDeleteConfirmation(camId, camName) {
		// Set the webcam name in the confirmation message
		const nameSpan = document.getElementById('delete-webcam-name');
		if (nameSpan) {
			nameSpan.textContent = camName;
		}
		
		// Setup buttons
		const confirmButton = document.getElementById('confirm-delete-btn');
		const cancelButton = document.getElementById('cancel-delete-btn');
		
		// Remove old event listeners to prevent duplicates
		const newConfirmButton = confirmButton.cloneNode(true);
		const newCancelButton = cancelButton.cloneNode(true);
		
		confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
		cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
		
		// Add event listeners
		newConfirmButton.addEventListener('click', function() {
			confirmDelete(camId);
		});
		
		newCancelButton.addEventListener('click', function() {
			hideDeleteConfirmation();
		});
		
		// Show the dialog
		const dialog = document.getElementById('confirmation-dialog');
		dialog.classList.remove('hidden');
	}
	
	// Confirm delete action
	function confirmDelete(camId) {
		// Find webcam to delete
		const camIndex = webcamConfig.findIndex(c => c.id === parseInt(camId));
		if (camIndex === -1) {
			logMessage("Error: Webcam not found");
			hideDeleteConfirmation();
			return;
		}
		
		const camName = webcamConfig[camIndex].name;
		
		// Remove the webcam 
		webcamConfig.splice(camIndex, 1);
		
		// Save to localStorage
		saveSettings();
		
		// Refresh the list
		populateWebcamList();
		
		logMessage(`Deleted webcam: ${camName}`);
		
		// Reload webcams if app is already loaded
		if (appLoaded) {
			loadWebcams();
			}
		
		// Hide the confirmation dialog
		hideDeleteConfirmation();
	}
	
	// Hide delete confirmation dialog
	function hideDeleteConfirmation() {
		const dialog = document.getElementById('confirmation-dialog');
		dialog.classList.add('hidden');
	}

	// Populate grid layout settings
	function populateGridLayoutSettings() {
		console.log("Populating grid layout settings with:", JSON.stringify(layoutSettings));
		
		// Ensure we have the most up-to-date settings
		try {
			const savedLayoutSettings = localStorage.getItem('layoutSettings');
			if (savedLayoutSettings) {
				// Refresh our layoutSettings object with the latest from localStorage
				const freshSettings = JSON.parse(savedLayoutSettings);
				// Only update if we actually got valid settings
				if (freshSettings && typeof freshSettings === 'object') {
					layoutSettings = freshSettings;
					console.log("Refreshed layout settings from localStorage:", JSON.stringify(layoutSettings));
				}
			}
		} catch (error) {
			console.error("Error refreshing layout settings:", error);
		}
		
		// Set up form values based on current settings
		const gridTypeSelect = document.getElementById('grid-type');
		const customOptions = document.getElementById('custom-grid-options');
		
		 // Explicitly create and replace the dropdown to ensure correct selection
		if (gridTypeSelect) {
			// Create a new select element to replace the existing one
			const newSelect = document.createElement('select');
			newSelect.id = 'grid-type';
			newSelect.className = 'form-control';
			
			// Create options
			const autoOption = document.createElement('option');
			autoOption.value = 'auto';
			autoOption.textContent = 'Auto (Dynamic)';
			
			const customOption = document.createElement('option');
			customOption.value = 'custom';
			customOption.textContent = 'Custom Grid';
			
			// Select the right option based on settings
			if (layoutSettings.autoLayout) {
				autoOption.selected = true;
			} else {
				customOption.selected = true;
			}
			
			// Add options to select element
			newSelect.appendChild(autoOption);
			newSelect.appendChild(customOption);
			
			// Replace the existing select with our new one
			gridTypeSelect.parentNode.replaceChild(newSelect, gridTypeSelect);
			
			// Add event listener to the new select
			newSelect.addEventListener('change', function() {
				const isAuto = this.value === 'auto';
				console.log(`Grid type changed to: ${this.value}, isAuto=${isAuto}`);
				if (customOptions) {
					customOptions.style.display = isAuto ? 'none' : 'block';
					console.log(`Updated custom options display: ${customOptions.style.display}`);
				}
				});
			
			// Ensure the custom options visibility matches the current selection
			if (customOptions) {
				customOptions.style.display = layoutSettings.autoLayout ? 'none' : 'block';
				console.log(`Set custom options display: ${customOptions.style.display}`);
			}
		}
		
		// Set the rows and columns input values
		const rowsInput = document.getElementById('grid-rows');
		const columnsInput = document.getElementById('grid-columns');
		
		if (rowsInput) rowsInput.value = layoutSettings.gridRows || 2;
		if (columnsInput) columnsInput.value = layoutSettings.gridColumns || 2;
		
		// Set additional settings
		const showLabelsCheckbox = document.getElementById('show-labels');
		const autoRefreshInput = document.getElementById('auto-refresh');
		
		if (showLabelsCheckbox) showLabelsCheckbox.checked = layoutSettings.showLabels;
		if (autoRefreshInput) autoRefreshInput.value = layoutSettings.refreshInterval;
		
		// Set up save and cancel buttons
		const saveButton = document.getElementById('save-layout-btn');
		const cancelButton = document.getElementById('cancel-layout-btn');
		
		if (saveButton && cancelButton) {
			// Remove old event listeners
			const newSaveButton = saveButton.cloneNode(true);
			const newCancelButton = cancelButton.cloneNode(true);
			
			saveButton.parentNode.replaceChild(newSaveButton, saveButton);
			cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
			
			// Add new event listeners
			newSaveButton.addEventListener('click', saveGridLayout);
			newCancelButton.addEventListener('click', () => showSettingsMode('list'));
			}
		
		// Force a redraw by toggling display
		if (customOptions) {
			const currentDisplay = customOptions.style.display;
			customOptions.style.display = 'none';
			setTimeout(() => {
				customOptions.style.display = currentDisplay;
			}, 0);
		}
	}

	// Save grid layout settings
	function saveGridLayout() {
		const gridType = document.getElementById('grid-type').value;
		
		// Set autoLayout based on selection
		layoutSettings.autoLayout = (gridType === 'auto');
		
		if (gridType === 'custom') {
			// Get custom grid dimensions
			layoutSettings.gridRows = parseInt(document.getElementById('grid-rows').value) || 2;
			layoutSettings.gridColumns = parseInt(document.getElementById('grid-columns').value) || 2;
		} else {
			// For auto layout, we'll calculate dimensions dynamically when applied
			// but still keep reasonable defaults in the settings
			layoutSettings.gridRows = 0;  // 0 indicates auto calculation
			layoutSettings.gridColumns = 0; // 0 indicates auto calculation
		}
		
		// Ensure grid dimensions are within acceptable ranges when custom
		if (gridType === 'custom') {
			layoutSettings.gridRows = Math.min(Math.max(layoutSettings.gridRows, 1), 6);
			layoutSettings.gridColumns = Math.min(Math.max(layoutSettings.gridColumns, 1), 6);
		}
		
		// Get other settings
		layoutSettings.showLabels = document.getElementById('show-labels').checked;
		layoutSettings.refreshInterval = parseInt(document.getElementById('auto-refresh').value) || 0;
		
		 // If refresh interval is enabled, ensure it's at least 5 seconds
		if (layoutSettings.refreshInterval > 0 && layoutSettings.refreshInterval < 5) {
			layoutSettings.refreshInterval = 5;
		}
		
		// Save to localStorage
		localStorage.setItem('layoutSettings', JSON.stringify(layoutSettings));
		
		// Apply new layout immediately if app is already loaded
		if (appLoaded) {
			applyGridLayout();
		}
		
		// Return to list mode
		showSettingsMode('list');
		
		logMessage("Grid layout settings saved and applied");
	}

	// Apply settings
	function applySettings() {
		saveGridLayout();
		closeSettingsMenu();
		// Reload webcams with new settings
		loadWebcams();
	}

	// Apply the current grid layout settings to the webcam grid
	function applyGridLayout() {
		console.log("Applying grid layout settings...");
		const webcamGrid = document.getElementById('webcam-grid');
		if (!webcamGrid) {
			console.error("Webcam grid element not found in applyGridLayout");
			return;
		}
		
		// Get all webcam containers
		const containers = document.querySelectorAll('.webcam-container');
		if (containers.length === 0) {
			console.log("No webcam containers found to apply layout");
			return;
		}
		
		// Show/hide labels based on settings
		containers.forEach(container => {
			const label = container.querySelector('.webcam-label');
			if (label) {
				label.style.display = layoutSettings.showLabels ? 'block' : 'none';
			}
		});
		
		// Calculate grid dimensions
		let rows, columns;
		
		if (layoutSettings.autoLayout) {
			// Calculate optimal grid dimensions based on number of containers
			const count = containers.length;
			
			if (count <= 1) {
				rows = 1;
				columns = 1;
			} else if (count <= 2) {
				rows = 1;
				columns = 2;
			} else if (count <= 4) {
				rows = 2;
				columns = 2;
			} else if (count <= 6) {
				rows = 2;
				columns = 3;
			} else if (count <= 9) {
				rows = 3;
				columns = 3;
			} else {
				rows = 3;
				columns = 4; // Maximum auto layout
			}
		} else {
			// Use custom dimensions
			rows = layoutSettings.gridRows || 2;
			columns = layoutSettings.gridColumns || 2;
		}
		
		// Apply grid layout using CSS grid
		webcamGrid.style.display = 'grid';
		webcamGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
		webcamGrid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
		
		// Update container sizes based on grid layout
		containers.forEach(container => {
			// Reset any previous specific sizing
			container.style.width = '';
			container.style.height = '';
			container.style.maxWidth = '';
			container.style.maxHeight = '';
		});
		
		logMessage(`Applied grid layout: ${rows}×${columns} ${layoutSettings.autoLayout ? '(Auto)' : '(Custom)'}`);
		
		// Set up auto-refresh if enabled
		setupAutoRefresh();
	}

	// Set up auto-refresh for webcam feeds
	function setupAutoRefresh() {
		// Clear any existing auto-refresh timer
		if (window.autoRefreshTimer) {
			clearInterval(window.autoRefreshTimer);
			window.autoRefreshTimer = null;
		}
		
		// If auto-refresh is enabled (interval > 0)
		if (layoutSettings.refreshInterval > 0) {
			const intervalMs = Math.max(layoutSettings.refreshInterval, 5) * 1000; // Minimum 5 seconds
			
			logMessage(`Auto-refresh enabled: ${layoutSettings.refreshInterval} seconds`);
			
			// Set up new timer
			window.autoRefreshTimer = setInterval(function() {
				// Only refresh if not in fullscreen mode and not in settings
				if (!isFullscreenMode && !isSettingsOpen) {
					logMessage("Auto-refreshing webcam feeds...");
					loadWebcams();
				}
			}, intervalMs);
		}
	}

	// Network connectivity monitoring
	function initNetworkMonitoring() {
		// Basic implementation to prevent errors
		console.log("Initializing network monitoring (placeholder)...");
		// Placeholder: Actual network monitoring logic will be implemented later
		// updateNetworkStatus(); // Initial check
		// window.addEventListener('online', updateNetworkStatus);
		// window.addEventListener('offline', updateNetworkStatus);
	}

	// Display log message
	function logMessage(message) {
		try { // Add try-catch here as well
			const logBox = document.getElementById('log-box');
			// Only try to update if the logBox exists
			if (logBox) {
				logBox.textContent = message;
				logBox.classList.add('show');

				// Hide the log box after 3 seconds
				setTimeout(function() {
					// Check again inside timeout in case element disappears
					if (logBox) {
						logBox.classList.remove('show');
					}
				}, 3000);
			} else {
				console.log("[Debug] LogBox element not found, logging to console only.");
			}
		} catch (error) {
			console.error("[Debug] Error in logMessage:", error);
		}
		// Always log to console
		console.log(`[WebcamApp] ${message}`);
	}
</script>

<body>
	<!-- Splash Screen -->
	<div id="splash-screen" class="splash-screen">
		<div class="splash-logo">Webcam Viewer</div>
		<div class="splash-spinner"></div>
		<div id="splash-message" class="splash-message">Initializing...</div>
	</div>

	<div class="container">
		<header class="header">
			<div class="header-left">
				<div class="app-title">Webcam Viewer</div>
			</div>
			<div class="clock" id="clock">--:--</div>
			<div class="header-right">
				<button id="settings-button" class="settings-button" title="Settings">
					Settings
				</button>
			</div>
		</header>
		
		<div class="webcam-grid" id="webcam-grid">
			<!-- Webcam containers will be dynamically inserted here -->
		</div>
		
		<div class="fullscreen-mode" id="fullscreen-mode">
			<video id="fullscreen-video" class="fullscreen-feed" autoplay playsinline></video>
			<div id="fullscreen-label" class="webcam-label"></div>
			<div class="navigation-hint">UP/DOWN: Change Camera | LEFT: Back to Grid</div>
		</div>
		
		<!-- Settings Overlay -->
		<div id="settings-overlay" class="settings-overlay">
			<div class="settings-modal">
				<div class="settings-header">
					<div class="settings-title">Webcam Settings</div>
				</div>
				<div id="settings-content" class="settings-content">
						<!-- Settings List Mode -->
						<div id="settings-list-mode" class="settings-section">
							<h3>Webcam Settings</h3>
							<div class="webcam-list" id="settings-webcam-list"></div>
							<div class="settings-buttons">
								<button id="add-webcam-btn" class="btn">Add Webcam</button>
								<button id="edit-layout-btn" class="btn">Grid Layout</button>
								<button id="cancel-settings-btn" class="btn">Cancel</button>
							</div>
						</div>

						<!-- Add Webcam Mode -->
						<div id="settings-add-mode" class="settings-section hidden">
							<h3>Add New Webcam</h3>
							<div class="add-webcam-form">
								<div class="form-group">
									<label for="new-webcam-name">Name:</label>
									<input type="text" id="new-webcam-name" class="form-control">
								</div>
								<div class="form-group">
									<label for="new-webcam-url">URL:</label>
									<input type="text" id="new-webcam-url" class="form-control">
								</div>
								<div class="form-group">
									<label>
										<input type="checkbox" id="new-webcam-enabled" checked>
										Enable this webcam
									</label>
								</div>
								<div class="form-buttons">
									<button id="save-new-webcam-btn" class="action-button">Save</button>
									<button id="cancel-add-webcam-btn" class="action-button">Cancel</button>
								</div>
							</div>
						</div>

						<!-- Edit Webcam Mode -->
						<div id="settings-edit-mode" class="settings-section hidden">
							<h3>Edit Webcam</h3>
							<div class="add-webcam-form">
								<input type="hidden" id="edit-webcam-id">
								<div class="form-group">
									<label for="edit-webcam-name">Name:</label>
									<input type="text" id="edit-webcam-name" class="form-control">
								</div>
								<div class="form-group">
									<label for="edit-webcam-url">URL:</label>
									<input type="text" id="edit-webcam-url" class="form-control">
								</div>
								<div class="form-group">
									<label>
										<input type="checkbox" id="edit-webcam-enabled">
										Enable this webcam
									</label>
								</div>
								<div class="form-buttons">
									<button id="save-edit-webcam-btn" class="action-button">Save</button>
									<button id="cancel-edit-webcam-btn" class="action-button">Cancel</button>
								</div>
							</div>
						</div>

						<!-- Grid Layout Mode -->
						<div id="settings-grid-layout-mode" class="settings-section hidden">
							<h3>Grid Layout Settings</h3>
							<div class="form-group">
								<label for="grid-type">Grid Type:</label>
								<select id="grid-type" class="form-control">
									<option value="auto">Auto (Dynamic)</option>
									<option value="custom">Custom Grid</option>
								</select>
							</div>
							<div class="form-group" id="custom-grid-options">
								<label for="grid-rows">Rows:</label>
								<input type="number" id="grid-rows" class="form-control" min="1" max="6" value="2">
								<label for="grid-columns">Columns:</label>
								<input type="number" id="grid-columns" class="form-control" min="1" max="6" value="2">
							</div>
							<div class="form-group">
								<label for="show-labels">Show Camera Labels:</label>
								<input type="checkbox" id="show-labels" checked>
							</div>
							<div class="form-group">
								<label for="auto-refresh">Auto-refresh Interval (seconds):</label>
								<input type="number" id="auto-refresh" class="form-control" min="0" max="300" value="0">
								<small>0 = disabled, min 5 seconds if enabled</small>
							</div>
							<div class="settings-buttons">
								<button id="save-layout-btn" class="btn">Save</button>
								<button id="cancel-layout-btn" class="btn">Cancel</button>
							</div>
						</div>
				</div>
				<div class="settings-footer">
					<button id="close-settings" class="action-button" onclick="closeSettingsMenu()">Close</button>
				</div>
			</div>
		</div>
		
		<!-- Custom confirmation dialog -->
		<div id="confirmation-dialog" class="confirmation-dialog hidden">
			<div class="confirmation-dialog-content">
				<div class="confirmation-dialog-header">Confirm Delete</div>
				<div class="confirmation-dialog-body">
					Are you sure you want to delete <span id="delete-webcam-name"></span>?
				</div>
				<div class="confirmation-dialog-footer">
					<button id="confirm-delete-btn" class="action-button delete">Delete</button>
					<button id="cancel-delete-btn" class="action-button">Cancel</button>
				</div>
			</div>
		</div>

		<div class="log-box" id="log-box">
			<!-- Log messages will appear here -->
		</div>
	</div>
</body>

</html>
