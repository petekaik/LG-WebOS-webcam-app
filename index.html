<!--
Copyright (c) 2024 LG Electronics Inc.

SPDX-License-Identifier: Apache-2.0
-->

<!DOCTYPE html>
<html>

<head>
	<title>Webcam Viewer</title>
	<style type="text/css">
		body {
			width: 100%;
			height: 100%;
			background-color: #202020;
			margin: 0;
			padding: 0;
			overflow: hidden;
			font-family: Arial, sans-serif;
			color: #FFFFFF;
		}

		.container {
			position: absolute;
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		.header {
			height: 60px;
			background-color: #101010;
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 0 20px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
			z-index: 10;
		}

		.header-left {
			display: flex;
			align-items: center;
			gap: 15px;
		}

		.app-title {
			font-size: 24px;
			font-weight: bold;
		}

		.header-right {
			display: flex;
			align-items: center;
			gap: 20px;
		}

		.clock {
			font-size: 24px;
		}

		.settings-button {
			background-color: transparent;
			border: none;
			color: #FFFFFF;
			cursor: pointer;
			font-size: 18px;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px;
			border-radius: 4px;
			transition: background-color 0.2s;
		}

		.settings-button.focused {
			background-color: rgba(66, 133, 244, 0.6);
		}

		.settings-button:hover {
			background-color: rgba(255, 255, 255, 0.1);
		}

		/* Fixed grid layout to display proper thumbnails */
		.webcam-grid {
			display: flex;
			flex-wrap: wrap;
			justify-content: center;
			align-items: center;
			gap: 20px;
			padding: 20px;
			box-sizing: border-box;
			width: 100%;
			height: calc(100% - 60px); /* Subtract header height */
			max-width: 1920px; /* Max width for 4K TVs */
			margin: 0 auto;
		}

		/* Fixed container sizing for proper grid cells */
		.webcam-container {
			position: relative;
			width: calc(50% - 20px); /* Adjust width for 2 columns with gap */
			height: calc(50% - 20px); /* Adjust height for 2 rows with gap */
			max-width: 640px;
			max-height: 360px;
			background-color: #303030;
			overflow: hidden;
			border-radius: 8px;
			border: 2px solid transparent;
		}

		.webcam-container.focused {
			border: 2px solid #4285f4;
			box-shadow: 0 0 15px rgba(66, 133, 244, 0.8);
			transform: scale(1.02);
			transition: transform 0.2s ease;
			z-index: 2;
		}

		.webcam-feed {
			width: 100%;
			height: 100%;
			object-fit: cover;
			background-color: #000;
		}

		.webcam-label {
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 8px;
			text-align: center;
		}

		.fullscreen-mode {
			position: absolute;
			top: 60px;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #000000;
			z-index: 9;
			display: none;
		}

		.fullscreen-feed {
			width: 100%;
			height: 100%;
			object-fit: contain;
		}

		.log-box {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background-color: rgba(0, 0, 0, 0.8);
			border-radius: 8px;
			padding: 10px 20px;
			min-width: 300px;
			max-width: 80%;
			text-align: center;
			opacity: 0;
			transition: opacity 0.3s;
			z-index: 20;
		}

		.log-box.show {
			opacity: 1;
		}

		.navigation-hint {
			position: absolute;
			bottom: 10px;
			right: 10px;
			background-color: rgba(0, 0, 0, 0.6);
			padding: 10px;
			border-radius: 5px;
			font-size: 14px;
			color: #FFFFFF;
		}
		
		.stream-placeholder {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			text-align: center;
			background-color: #303030;
			color: #aaaaaa;
			padding: 20px;
		}
		
		.stream-placeholder-icon {
			font-size: 32px;
			margin-bottom: 10px;
		}
		
		.stream-placeholder-text {
			font-size: 14px;
			max-width: 80%;
		}

		/* Settings modal styling */
		.settings-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.7);
			z-index: 100;
			display: none;
			justify-content: center;
			align-items: center;
		}

		.settings-modal {
			width: 80%;
			max-width: 800px;
			max-height: 80vh;
			background-color: #303030;
			border-radius: 8px;
			box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
			overflow: hidden;
			display: flex;
			flex-direction: column;
		}

		.settings-header {
			background-color: #202020;
			padding: 15px 20px;
			display: flex;
			justify-content: space-between;
			align-items: center;
			border-bottom: 1px solid #404040;
		}

		.settings-title {
			font-size: 22px;
			font-weight: bold;
		}

		.settings-close {
			background: transparent;
			border: none;
			color: #FFFFFF;
			font-size: 22px;
			cursor: pointer;
		}

		.settings-content {
			flex: 1;
			padding: 20px;
			overflow-y: auto;
		}

		.settings-section {
			margin-bottom: 25px;
		}

		.settings-section-title {
			font-size: 18px;
			font-weight: bold;
			margin-bottom: 15px;
			border-bottom: 1px solid #404040;
			padding-bottom: 5px;
		}

		.webcam-list {
			display: flex;
			flex-direction: column;
			gap: 15px;
		}

		.webcam-item {
			background-color: #252525;
			border-radius: 6px;
			padding: 15px;
			display: flex;
			justify-content: space-between;
			align-items: center;
			transition: background-color 0.2s;
		}

		.webcam-item.focused {
			background-color: #3a3a3a;
			box-shadow: 0 0 0 2px #4285f4;
		}

		.webcam-item-info {
			flex: 1;
		}

		.webcam-item-name {
			font-weight: bold;
			margin-bottom: 5px;
		}

		.webcam-item-url {
			font-size: 12px;
			color: #aaaaaa;
			word-break: break-all;
		}

		.webcam-item-actions {
			display: flex;
			gap: 10px;
		}

		.action-button {
			background-color: transparent;
			border: 1px solid #505050;
			color: #FFFFFF;
			padding: 6px 10px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.2s;
		}

		.action-button:hover, .action-button.focused {
			background-color: rgba(66, 133, 244, 0.2);
			border-color: #4285f4;
		}

		.action-button.delete {
			border-color: #ff4d4d;
			color: #ff4d4d;
		}

		.action-button.delete:hover, .action-button.delete.focused {
			background-color: rgba(255, 77, 77, 0.2);
		}

		.add-webcam-form {
			background-color: #252525;
			border-radius: 6px;
			padding: 15px;
		}

		.form-group {
			margin-bottom: 15px;
		}

		.form-group label {
			display: block;
			margin-bottom: 5px;
			font-size: 14px;
		}

		.form-control {
			width: 100%;
			padding: 10px;
			background-color: #404040;
			border: 1px solid #505050;
			color: #FFFFFF;
			border-radius: 4px;
			font-size: 16px;
			box-sizing: border-box;
		}

		.form-control.focused {
			border-color: #4285f4;
			box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.4);
		}

		.form-buttons {
			display: flex;
			justify-content: flex-end;
			gap: 10px;
			margin-top: 20px;
		}

		.settings-footer {
			background-color: #252525;
			padding: 15px 20px;
			display: flex;
			justify-content: flex-end;
			gap: 10px;
			border-top: 1px solid #404040;
		}
		
		/* Splash screen styling */
		.splash-screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: #101010;
			z-index: 1000;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			transition: opacity 0.5s ease-in-out;
		}
		
		.splash-logo {
			font-size: 42px;
			font-weight: bold;
			color: #FFFFFF;
			margin-bottom: 20px;
			text-align: center;
		}
		
		.splash-spinner {
			width: 60px;
			height: 60px;
			border: 5px solid rgba(255, 255, 255, 0.3);
			border-radius: 50%;
			border-top-color: #FFFFFF;
			animation: spin 1s ease-in-out infinite;
		}
		
		@keyframes spin {
			to { transform: rotate(360deg); }
		}
		
		.splash-message {
			margin-top: 20px;
			font-size: 18px;
			color: #CCCCCC;
		}
		
		.hidden {
			opacity: 0;
			pointer-events: none;
		}

		/* General Styles */
		body {
			margin: 0;
			padding: 0;
			background-color: #000;
			color: #fff;
			font-family: Arial, sans-serif;
			overflow: hidden;
		}

		/* Grid Layout */
		.video-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			grid-gap: 10px;
			padding: 10px;
			height: calc(100vh - 60px);
		}

		/* Settings Panel */
		.settings-menu {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: rgba(0, 0, 0, 0.9);
			border: 1px solid #444;
			border-radius: 10px;
			padding: 20px;
			width: 60%;
			max-height: 80%;
			overflow-y: auto;
			z-index: 1000;
		}

		.hidden {
			display: none;
		}

		.settings-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
			border-bottom: 1px solid #444;
			padding-bottom: 10px;
		}

		.settings-section {
			margin-bottom: 20px;
		}

		.form-group {
			margin-bottom: 15px;
		}

		.form-group label {
			display: block;
			margin-bottom: 5px;
		}

		.form-group input[type="text"],
		.form-group select {
			width: 100%;
			padding: 10px;
			background-color: #333;
			border: 1px solid #555;
			color: #fff;
			border-radius: 5px;
		}

		.form-group input[type="checkbox"] {
			width: 20px;
			height: 20px;
			vertical-align: middle;
		}

		.settings-buttons {
			display: flex;
			justify-content: flex-end;
			gap: 10px;
			margin-top: 20px;
		}

		.btn {
			padding: 10px 15px;
			background-color: #1d86e2;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			font-size: 16px;
		}

		.btn-close {
			background-color: transparent;
			font-weight: bold;
			font-size: 20px;
		}

		.btn:hover, .btn:focus {
			background-color: #0e6ab7;
		}

		.btn-close:hover, .btn-close:focus {
			color: #1d86e2;
			background-color: transparent;
		}

		.webcam-list {
			margin-bottom: 15px;
		}

		.webcam-item {
			padding: 10px;
			background-color: #333;
			margin-bottom: 5px;
			border-radius: 5px;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.webcam-item-selected {
			background-color: #1d86e2;
		}

		.webcam-item-name {
			font-weight: bold;
		}

		/* Video Container */
		.video-container {
			position: relative;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}

		.video-container video {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.video-container.selected {
			border: 3px solid #1d86e2;
		}

		.video-overlay {
			position: absolute;
			bottom: 10px;
			left: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 5px 10px;
			border-radius: 5px;
		}

		/* Clock */
		.clock {
			position: absolute;
			top: 10px;
			right: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 5px 10px;
			border-radius: 5px;
			font-size: 20px;
		}

		/* Log Box */
		.log-container {
			position: absolute;
			bottom: 10px;
			right: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 5px;
			max-width: 300px;
			max-height: 200px;
			overflow-y: auto;
			opacity: 0;
			transition: opacity 0.3s ease;
		}

		.log-container.visible {
			opacity: 1;
		}

		.log-entry {
			margin-bottom: 5px;
			font-size: 14px;
		}

		.log-entry.error {
			color: #ff5252;
		}

		.log-entry.info {
			color: #4caf50;
		}

		/* Network Status Indicator */
		.network-status {
			position: absolute;
			top: 10px;
			left: 10px;
			display: flex;
			align-items: center;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 5px 10px;
			border-radius: 5px;
		}

		.network-indicator {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			margin-right: 8px;
		}

		.network-online {
			background-color: #4caf50;
		}

		.network-offline {
			background-color: #ff5252;
		}

		/* Fullscreen mode */
		.fullscreen-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 900;
			background-color: #000;
		}

		.fullscreen-container video {
			width: 100%;
			height: 100%;
			object-fit: contain;
		}

		.fullscreen-overlay {
			position: absolute;
			bottom: 20px;
			left: 20px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 5px;
			font-size: 24px;
		}

		/* Media queries for responsive design */
		@media (max-width: 768px) {
			.video-grid {
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			}
		}

        /* Grid Layout Settings */
        #custom-grid-options {
            margin-top: 15px;
        }
        
        #custom-grid-options input {
            width: 50px;
            margin-right: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-control {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        /* Network Status Indicator */
        #network-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            color: white;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .status-online {
            background-color: #2ecc71;
        }
        
        .status-offline {
            background-color: #e74c3c;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
		/* Base styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'LG Smart', 'Roboto', sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* Network status indicator styles */
        #network-status {
            display: flex;
            align-items: center;
            margin-left: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }
        
        .status-online {
            background-color: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }
        
        .status-offline {
            background-color: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        /* Grid settings specific styles */
        .form-group {
            margin-bottom: 15px;
        }
        
        #custom-grid-options {
            margin-top: 5px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
	</style>
</head>

<script src="webOSTVjs-1.2.10/webOSTV.js" charset="utf-8"></script>
<script src="webOSTVjs-1.2.10/webOSTV-dev.js" charset="utf-8"></script>
<script type="text/javascript">
	// Default webcam configuration
    const defaultWebcamConfig = [
        { id: 1, name: 'Front Door', url: 'http://192.168.1.100:8080/video', enabled: true },
        { id: 2, name: 'Back Yard', url: 'http://192.168.1.101:8080/video', enabled: true },
        { id: 3, name: 'Living Room', url: 'http://192.168.1.102:8080/video', enabled: false },
        { id: 4, name: 'Garage', url: 'http://192.168.1.103:8080/video', enabled: false }
    ];

    // Default layout settings
    const defaultLayoutSettings = {
        gridRows: 2,
        gridColumns: 2,
        autoLayout: true,
        showLabels: true,
        refreshInterval: 0 // 0 means no refresh, value in seconds
    };

    // Global variables
    let webcamConfig = [];
    let layoutSettings = {};
    let selectedWebcam = null;
    let isFullscreen = false;
	let currentFocusedCam = null;
	let isFullscreenMode = false;
	let activeFullscreenCam = null;
	let isSettingsOpen = false;
	let clockInterval;
	let appLoaded = false;
	let loadedStreams = 0;
	let networkStatus = "online";

	// Settings menu variables
	let settingsMode = 'list'; // 'list', 'add', 'edit', 'layout'
	let settingsFocusedElement = null;
	let editingWebcamId = null;

	// Initialize the application when DOM is loaded
	document.addEventListener('DOMContentLoaded', function() {
		showSplashScreen();
		loadSettings();
		initializeClock();
		initNetworkMonitoring();  // Initialize network monitoring
		loadWebcams();
		setupNavigation();
		
		// Apply grid layout after loading webcams
		setTimeout(() => {
			applyGridLayout();
		}, 500);
		
		// Hide splash screen after a minimum time (ensures it's visible for at least 2 seconds)
		setTimeout(function() {
			checkAllResourcesLoaded();
		}, 2000);
	});
	
	// Load settings from localStorage
	function loadSettings() {
		try {
			const savedWebcams = localStorage.getItem('webcamConfig');
			webcamConfig = savedWebcams ? JSON.parse(savedWebcams) : defaultWebcamConfig;
			
			const savedLayoutSettings = localStorage.getItem('layoutSettings');
			layoutSettings = savedLayoutSettings ? JSON.parse(savedLayoutSettings) : defaultLayoutSettings;
			
			logMessage("Settings loaded successfully");
		} catch (error) {
			logError(`Error loading settings: ${error.message}`);
			webcamConfig = defaultWebcamConfig;
			layoutSettings = defaultLayoutSettings;
		}
	}

	// Save settings to local storage
	function saveSettings() {
		try {
			localStorage.setItem('webcamConfig', JSON.stringify(webcamConfig));
			logMessage("Settings saved successfully");
			return true;
		} catch (error) {
			logMessage("Error saving settings");
			console.error("Settings save error:", error);
			return false;
		}
	}
	
	// Show the splash screen
	function showSplashScreen() {
		const splashScreen = document.getElementById('splash-screen');
		splashScreen.classList.remove('hidden');
	}
	
	// Hide the splash screen
	function hideSplashScreen() {
		if (appLoaded) return; // Avoid hiding multiple times
		
		const splashScreen = document.getElementById('splash-screen');
		splashScreen.classList.add('hidden');
		appLoaded = true;
		
		// Remove splash screen from DOM after transition
		setTimeout(function() {
			splashScreen.style.display = 'none';
		}, 500);
		
		logMessage("Webcam app initialized");
	}
	
	// Check if all resources have loaded
	function checkAllResourcesLoaded() {
		// We'll hide the splash screen if either:
		// 1. At least one stream has loaded successfully
		// 2. All streams have been attempted (success or failure)
		if (loadedStreams > 0 || loadedStreams == -webcamConfig.length) {
			hideSplashScreen();
		} else {
			// If nothing has loaded yet, wait a bit longer and check again
			setTimeout(function() {
				hideSplashScreen(); // Force hide after timeout
			}, 3000);
		}
	}

	// Initialize clock display
	function initializeClock() {
		updateClock();
		clockInterval = setInterval(updateClock, 1000);
	}

	// Update clock with current time
	function updateClock() {
		webOS.service.request("luna://com.palm.systemservice", {
			method: "clock/getTime",
			parameters: {},
			onSuccess: function (args) {
				const date = new Date(args.utc * 1000);
				const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
				document.getElementById('clock').textContent = timeString;
			},
			onFailure: function (args) {
				logMessage("Failed to get time");
				document.getElementById('clock').textContent = "Time not available";
			}
		});
	}

	// Load webcam feeds
	function loadWebcams() {
		const webcamGrid = document.getElementById('webcam-grid');
		webcamGrid.innerHTML = ''; // Clear any existing content
		
		webcamConfig.forEach((cam, index) => {
			const container = document.createElement('div');
			container.className = 'webcam-container';
			container.setAttribute('data-cam-id', cam.id);
			container.id = `cam-container-${cam.id}`;
			
			// If this is the first camera, set it as focused
			if (index === 0) {
				container.className += ' focused';
				currentFocusedCam = cam.id;
			}
			
			// Create a video element for the stream
			const video = document.createElement('video');
			video.className = 'webcam-feed';
			video.id = `video-${cam.id}`;
			video.muted = true; // Mute video in grid view as per FR-1.3
			video.autoplay = true;
			video.playsInline = true;
			video.setAttribute('playsinline', '');
			
			// Update splash screen message
			document.getElementById('splash-message').textContent = `Loading ${cam.name} feed...`;
			
			// Handle video source with error handling
			try {
				video.src = cam.url;
				
				// Add event handlers for video
				video.onerror = function(e) {
					handleVideoError(container, cam);
					loadedStreams--;
					checkAllResourcesLoaded();
				};
				
				video.onloadstart = function() {
					logMessage(`Loading ${cam.name} feed...`);
				};
				
				video.oncanplay = function() {
					logMessage(`${cam.name} feed ready`);
					loadedStreams++;
					checkAllResourcesLoaded();
				};
			} catch (error) {
				handleVideoError(container, cam);
				loadedStreams--;
				checkAllResourcesLoaded();
			}
			
			const label = document.createElement('div');
			label.className = 'webcam-label';
			label.textContent = cam.name;
			
			container.appendChild(video);
			container.appendChild(label);
			webcamGrid.appendChild(container);
			
			// Add click event for switching to full-screen mode
			container.addEventListener('click', function() {
				enterFullscreenMode(cam.id);
			});
		});
	}
	
	// Handle video loading errors
	function handleVideoError(container, cam) {
		logMessage(`Error loading ${cam.name} feed`);
		
		// Remove video element
		const video = container.querySelector('video');
		if (video) {
			video.remove();
		}
		
		// Add placeholder with friendly message instead of just an error
		const placeholder = document.createElement('div');
		placeholder.className = 'stream-placeholder';
		
		const icon = document.createElement('div');
		icon.className = 'stream-placeholder-icon';
		icon.innerHTML = '📷';
		
		const message = document.createElement('div');
		message.className = 'stream-placeholder-text';
		message.innerHTML = `<strong>${cam.name}</strong> stream is currently unavailable.<br>Please check your network connection or camera status.`;		
		placeholder.appendChild(icon);
		placeholder.appendChild(message);
		container.appendChild(placeholder);
	}

	// Set up navigation with remote control
	function setupNavigation() {
		document.addEventListener('keydown', function(event) {
			if (isSettingsOpen) {
				handleSettingsNavigation(event);
			} else if (isFullscreenMode) {
				handleFullscreenNavigation(event);
			} else {
				handleGridNavigation(event);
			}
		});
		
		// Add settings button click handler
		document.getElementById('settings-button').addEventListener('click', function() {
			openSettingsMenu();
		});
	}

	// Handle navigation in grid view
	function handleGridNavigation(event) {
		// Handle settings button focus
		if (event.keyCode === 38 && webcamConfig.length > 0) { // UP arrow from first row
			const currentIndex = webcamConfig.findIndex(cam => cam.id === currentFocusedCam);
			if (currentIndex < webcamConfig.length / 2) { // If in first row
				const currentFocused = document.querySelector('.webcam-container.focused');
				if (currentFocused) {
					currentFocused.classList.remove('focused');
				}
				const settingsButton = document.getElementById('settings-button');
				settingsButton.classList.add('focused');
				return;
			}
		}
		
		// If settings button is focused and arrow pressed
		const settingsButton = document.getElementById('settings-button');
		if (settingsButton.classList.contains('focused')) {
			if (event.keyCode === 40) { // DOWN arrow
				settingsButton.classList.remove('focused');
				// Focus first webcam
				const firstCam = webcamConfig[0];
				if (firstCam) {
					focusCamera(firstCam.id);
				}
				return;
			} else if (event.keyCode === 13) { // ENTER
				openSettingsMenu();
				return;
			}
		}
		
		// Regular grid navigation
		const grid = document.getElementById('webcam-grid');
		const numColumns = 2;
		const numRows = Math.ceil(webcamConfig.length / numColumns);
		
		// Find the current camera's position in the grid
		const currentIndex = webcamConfig.findIndex(cam => cam.id === currentFocusedCam);
		const currentRow = Math.floor(currentIndex / numColumns);
		const currentCol = currentIndex % numColumns;
		
		let newRow = currentRow;
		let newCol = currentCol;
		
		switch (event.keyCode) {
			case 37: // LEFT arrow
				newCol = Math.max(0, currentCol - 1);
				break;
			case 38: // UP arrow
				newRow = Math.max(0, currentRow - 1);
				break;
			case 39: // RIGHT arrow
				newCol = Math.min(numColumns - 1, currentCol + 1);
				break;
			case 40: // DOWN arrow
				newRow = Math.min(numRows - 1, currentRow + 1);
				break;
			case 13: // ENTER key
				// Enter fullscreen mode for the currently focused camera
				enterFullscreenMode(currentFocusedCam);
				return;
			case 82: // R key (shortcut for settings)
				openSettingsMenu();
				return;
			default:
				return;
		}
		
		const newIndex = newRow * numColumns + newCol;
		if (newIndex >= 0 && newIndex < webcamConfig.length) {
			focusCamera(webcamConfig[newIndex].id);
		}
	}
	
	// Open the settings menu
	function openSettingsMenu() {
		const settingsOverlay = document.getElementById('settings-overlay');
		settingsOverlay.style.display = 'flex';
		isSettingsOpen = true;
		
		// Reset settings state
		settingsMode = 'list';
		renderSettingsContent();
		
		// Initial focus on first webcam or add button if no webcams
		setTimeout(() => {
			if (webcamConfig.length > 0) {
				focusSettingsElement('webcam-item-0');
			} else {
				focusSettingsElement('add-webcam-button');
			}
		}, 100);
	}
	
	// Close the settings menu
	function closeSettingsMenu() {
		const settingsOverlay = document.getElementById('settings-overlay');
		settingsOverlay.style.display = 'none';
		isSettingsOpen = false;
		
		// Remove focus from settings button
		document.getElementById('settings-button').classList.remove('focused');
		
		// Focus back on a camera if available
		if (webcamConfig.length > 0) {
			focusCamera(webcamConfig[0].id);
		}
	}
	
	// Render the appropriate settings content based on mode
	function renderSettingsContent() {
		const settingsContent = document.getElementById('settings-content');
		
		if (settingsMode === 'list') {
			// Render webcam list
			let content = `
				<div class="settings-section">
					<div class="settings-section-title">Webcam Feeds</div>
					<div class="webcam-list">
			`;
			
			if (webcamConfig.length === 0) {
				content += `
					<div class="webcam-item">
						<div class="webcam-item-info">No webcams configured</div>
					</div>
				`;
			} else {
				webcamConfig.forEach((cam, index) => {
					content += `
						<div id="webcam-item-${index}" class="webcam-item" data-cam-id="${cam.id}">
							<div class="webcam-item-info">
								<div class="webcam-item-name">${cam.name}</div>
								<div class="webcam-item-url">${cam.url}</div>
							</div>
							<div class="webcam-item-actions">
								<button id="edit-button-${index}" class="action-button" onclick="editWebcam(${cam.id})">Edit</button>
								<button id="delete-button-${index}" class="action-button delete" onclick="deleteWebcam(${cam.id})">Delete</button>
							</div>
						</div>
					`;
				});
			}
			
			content += `
					</div>
					<div class="form-buttons">
						<button id="add-webcam-button" class="action-button" onclick="showAddWebcamForm()">Add Webcam</button>
						<button id="grid-settings-button" class="action-button" onclick="showGridSettings()">Grid Settings</button>
					</div>
				</div>
			`;
			
			settingsContent.innerHTML = content;
			
		} else if (settingsMode === 'add' || settingsMode === 'edit') {
			// Get webcam data if editing
			let webcamData = { name: '', url: '' };
			if (settingsMode === 'edit' && editingWebcamId !== null) {
				const webcam = webcamConfig.find(cam => cam.id === editingWebcamId);
				if (webcam) {
					webcamData = { name: webcam.name, url: webcam.url };
				}
			}
			
			// Render add/edit form
			const formTitle = settingsMode === 'add' ? 'Add Webcam' : 'Edit Webcam';
			const submitAction = settingsMode === 'add' ? 'addWebcam()' : 'updateWebcam()';
			
			let content = `
				<div class="settings-section">
					<div class="settings-section-title">${formTitle}</div>
					<div class="add-webcam-form">
						<div class="form-group">
							<label for="webcam-name">Webcam Name</label>
							<input type="text" id="webcam-name" class="form-control" placeholder="Enter webcam name" value="${webcamData.name}">
						</div>
						<div class="form-group">
							<label for="webcam-url">Stream URL</label>
							<input type="text" id="webcam-url" class="form-control" placeholder="Enter stream URL (e.g., http://example.com/stream.m3u8)" value="${webcamData.url}">
						</div>
						<div class="form-buttons">
							<button id="cancel-button" class="action-button" onclick="cancelAddEdit()">Cancel</button>
							<button id="submit-button" class="action-button" onclick="${submitAction}">Save</button>
						</div>
					</div>
				</div>
			`;
			
			settingsContent.innerHTML = content;
		}
	}
	
	// Show the form to add a new webcam
	function showAddWebcamForm() {
		settingsMode = 'add';
		renderSettingsContent();
		
		// Focus on the name input
		setTimeout(() => {
			focusSettingsElement('webcam-name');
		}, 100);
	}
	
	// Edit an existing webcam
	function editWebcam(camId) {
		editingWebcamId = camId;
		settingsMode = 'edit';
		renderSettingsContent();
		
		// Focus on the name input
		setTimeout(() => {
			focusSettingsElement('webcam-name');
		}, 100);
	}
	
	// Add a new webcam
	function addWebcam() {
		const nameInput = document.getElementById('webcam-name');
		const urlInput = document.getElementById('webcam-url');
		
		const name = nameInput.value.trim();
		const url = urlInput.value.trim();
		
		if (!name || !url) {
			logMessage("Please fill in all fields");
			return;
		}
		
		// Generate a new unique ID
		const maxId = webcamConfig.reduce((max, cam) => Math.max(max, cam.id), 0);
		const newId = maxId + 1;
		
		// Add the new webcam
		webcamConfig.push({ id: newId, name, url });
		
		// Save and reload
		if (saveSettings()) {
			logMessage(`Added webcam: ${name}`);
			
			// Return to list view
			settingsMode = 'list';
			renderSettingsContent();
			
			// Focus on the newly added webcam
			setTimeout(() => {
				focusSettingsElement(`webcam-item-${webcamConfig.length - 1}`);
			}, 100);
		}
	}
	
	// Update an existing webcam
	function updateWebcam() {
		if (editingWebcamId === null) return;
		
		const nameInput = document.getElementById('webcam-name');
		const urlInput = document.getElementById('webcam-url');
		
		const name = nameInput.value.trim();
		const url = urlInput.value.trim();
		
		if (!name || !url) {
			logMessage("Please fill in all fields");
			return;
		}
		
		// Find and update the webcam
		const index = webcamConfig.findIndex(cam => cam.id === editingWebcamId);
		if (index !== -1) {
			webcamConfig[index].name = name;
			webcamConfig[index].url = url;
			
			// Save and reload
			if (saveSettings()) {
				logMessage(`Updated webcam: ${name}`);
				
				// Return to list view
				settingsMode = 'list';
				renderSettingsContent();
				
				// Focus on the updated webcam
				setTimeout(() => {
					focusSettingsElement(`webcam-item-${index}`);
				}, 100);
			}
		}
	}
	
	// Delete a webcam
	function deleteWebcam(camId) {
		// Find the webcam
		const index = webcamConfig.findIndex(cam => cam.id === camId);
		if (index !== -1) {
			const camName = webcamConfig[index].name;
			
			// Remove the webcam
			webcamConfig.splice(index, 1);
			
			// Save and reload
			if (saveSettings()) {
				logMessage(`Deleted webcam: ${camName}`);
				
				// Update the list
				renderSettingsContent();
				
				// Focus on another webcam or add button
				setTimeout(() => {
					if (webcamConfig.length > 0) {
						const newIndex = Math.min(index, webcamConfig.length - 1);
						focusSettingsElement(`webcam-item-${newIndex}`);
					} else {
						focusSettingsElement('add-webcam-button');
					}
				}, 100);
			}
		}
	}
	
	// Cancel add/edit and return to list
	function cancelAddEdit() {
		editingWebcamId = null;
		settingsMode = 'list';
		renderSettingsContent();
		
		// Focus on the first webcam or add button
		setTimeout(() => {
			if (webcamConfig.length > 0) {
				focusSettingsElement('webcam-item-0');
			} else {
				focusSettingsElement('add-webcam-button');
			}
		}, 100);
	}
	
	// Apply settings and reload webcams
	function applySettings() {
		loadWebcams();
		closeSettingsMenu();
		logMessage("Settings applied");
	}
	
	// Focus a settings element
	function focusSettingsElement(elementId) {
		// Remove focus from previous element
		const previousFocused = document.querySelector('.focused:not(.webcam-container)');
		if (previousFocused) {
			previousFocused.classList.remove('focused');
		}
		
		// Focus new element
		const element = document.getElementById(elementId);
		if (element) {
			element.classList.add('focused');
			settingsFocusedElement = elementId;
			
			// If input, focus it for keyboard input
			if (element.tagName === 'INPUT') {
				element.focus();
			}
		}
	}
	
	// Handle navigation in settings menu
	function handleSettingsNavigation(event) {
		if (!settingsFocusedElement) return;
		
		if (event.keyCode === 461 || event.keyCode === 27) { // Back button or ESC key
			if (settingsMode === 'add' || settingsMode === 'edit') {
				// Return to list view
				cancelAddEdit();
			} else {
				// Close settings
				applySettings();
			}
			return;
		}
		
		if (settingsMode === 'list') {
			handleSettingsListNavigation(event);
		} else if (settingsMode === 'add' || settingsMode === 'edit') {
			handleSettingsFormNavigation(event);
		}
	}
	
	// Handle navigation in settings list view
	function handleSettingsListNavigation(event) {
		// Check if we're on a webcam item
		const match = settingsFocusedElement.match(/webcam-item-(\d+)/);
		if (match) {
			const currentIndex = parseInt(match[1]);
			
			switch (event.keyCode) {
				case 38: // UP arrow
					if (currentIndex > 0) {
						// Focus previous webcam
						focusSettingsElement(`webcam-item-${currentIndex - 1}`);
					}
					break;
					
				case 40: // DOWN arrow
					if (currentIndex < webcamConfig.length - 1) {
						// Focus next webcam
						focusSettingsElement(`webcam-item-${currentIndex + 1}`);
					} else {
						// Focus add button
						focusSettingsElement('add-webcam-button');
					}
					break;
					
				case 39: // RIGHT arrow
					// Focus edit button
					focusSettingsElement(`edit-button-${currentIndex}`);
					break;
					
				case 13: // ENTER key
					// Edit this webcam
					editWebcam(webcamConfig[currentIndex].id);
					break;
			}
		}
		// Check if we're on an edit button
		else if (settingsFocusedElement.match(/edit-button-(\d+)/)) {
			const currentIndex = parseInt(settingsFocusedElement.match(/edit-button-(\d+)/)[1]);
			
			switch (event.keyCode) {
				case 37: // LEFT arrow
					// Return to webcam item
					focusSettingsElement(`webcam-item-${currentIndex}`);
					break;
					
				case 39: // RIGHT arrow
					// Focus delete button
					focusSettingsElement(`delete-button-${currentIndex}`);
					break;
					
				case 13: // ENTER key
					// Edit this webcam
					editWebcam(webcamConfig[currentIndex].id);
					break;
			}
		}
		// Check if we're on a delete button
		else if (settingsFocusedElement.match(/delete-button-(\d+)/)) {
			const currentIndex = parseInt(settingsFocusedElement.match(/delete-button-(\d+)/)[1]);
			
			switch (event.keyCode) {
				case 37: // LEFT arrow
					// Focus edit button
					focusSettingsElement(`edit-button-${currentIndex}`);
					break;
					
				case 13: // ENTER key
					// Delete this webcam
					deleteWebcam(webcamConfig[currentIndex].id);
					break;
			}
		}
		// Check if we're on the add button
		else if (settingsFocusedElement === 'add-webcam-button') {
			switch (event.keyCode) {
				case 38: // UP arrow
					if (webcamConfig.length > 0) {
						// Focus last webcam
						focusSettingsElement(`webcam-item-${webcamConfig.length - 1}`);
					}
					break;
					
				case 13: // ENTER key
					// Show add form
					showAddWebcamForm();
					break;
			}
		}
	}
	
	// Handle navigation in settings form
	function handleSettingsFormNavigation(event) {
		switch (event.keyCode) {
			case 38: // UP arrow
				if (settingsFocusedElement === 'webcam-url') {
					focusSettingsElement('webcam-name');
				} else if (settingsFocusedElement === 'submit-button' || settingsFocusedElement === 'cancel-button') {
					focusSettingsElement('webcam-url');
				}
				break;
				
			case 40: // DOWN arrow
				if (settingsFocusedElement === 'webcam-name') {
					focusSettingsElement('webcam-url');
				} else if (settingsFocusedElement === 'webcam-url') {
					focusSettingsElement('cancel-button');
				}
				break;
				
			case 37: // LEFT arrow
				if (settingsFocusedElement === 'submit-button') {
					focusSettingsElement('cancel-button');
				}
				break;
				
			case 39: // RIGHT arrow
				if (settingsFocusedElement === 'cancel-button') {
					focusSettingsElement('submit-button');
				}
				break;
				
			case 13: // ENTER key
				if (settingsFocusedElement === 'cancel-button') {
					cancelAddEdit();
				} else if (settingsFocusedElement === 'submit-button') {
					if (settingsMode === 'add') {
						addWebcam();
					} else {
						updateWebcam();
					}
				}
				break;
		}
	}

	// Handle navigation in fullscreen mode
	function handleFullscreenNavigation(event) {
		switch (event.keyCode) {
			case 38: // UP arrow
				cycleCameraFullscreen(-1);
				break;
			case 40: // DOWN arrow
				cycleCameraFullscreen(1);
				break;
			case 461: // Back button
			case 27:  // ESC key
				exitFullscreenMode();
				break;
			default:
				return;
		}
	}

	// Focus on a specific camera in the grid
	function focusCamera(camId) {
		// Remove focus from current camera
		const currentFocused = document.querySelector('.webcam-container.focused');
		if (currentFocused) {
			currentFocused.classList.remove('focused');
		}
		
		// Set focus on new camera
		const newFocused = document.querySelector(`#cam-container-${camId}`);
		if (newFocused) {
			newFocused.classList.add('focused');
			currentFocusedCam = camId;
		}
	}

	// Enter fullscreen mode for a specific camera
	function enterFullscreenMode(camId) {
		const cam = webcamConfig.find(c => c.id === camId);
		if (!cam) return;
		
		const fullscreenMode = document.getElementById('fullscreen-mode');
		const fullscreenVideo = document.getElementById('fullscreen-video');
		const fullscreenLabel = document.getElementById('fullscreen-label');
		
		// Check if we need to create a placeholder for unavailable stream
		const originalContainer = document.getElementById(`cam-container-${camId}`);
		if (originalContainer.querySelector('.stream-placeholder')) {
			// If stream is unavailable in grid view, show placeholder in fullscreen too
			fullscreenVideo.style.display = 'none';
			
			// Create fullscreen placeholder if it doesn't exist yet
			let fullscreenPlaceholder = document.getElementById('fullscreen-placeholder');
			if (!fullscreenPlaceholder) {
				fullscreenPlaceholder = document.createElement('div');
				fullscreenPlaceholder.className = 'stream-placeholder';
				fullscreenPlaceholder.id = 'fullscreen-placeholder';
				
				const icon = document.createElement('div');
				icon.className = 'stream-placeholder-icon';
				icon.innerHTML = '📷';
				icon.style.fontSize = '64px';
				
				const message = document.createElement('div');
				message.className = 'stream-placeholder-text';
				message.style.fontSize = '24px';
				message.style.maxWidth = '60%';
				message.innerHTML = `<strong>${cam.name}</strong> stream is currently unavailable.<br>Please check your network connection or camera status.`;				
				fullscreenPlaceholder.appendChild(icon);
				fullscreenPlaceholder.appendChild(message);
				fullscreenMode.appendChild(fullscreenPlaceholder);
			} else {
				// Update existing placeholder
				const message = fullscreenPlaceholder.querySelector('.stream-placeholder-text');
				if (message) {
					message.innerHTML = `<strong>${cam.name}</strong> stream is currently unavailable.<br>Please check your network connection or camera status.`;
				}
				fullscreenPlaceholder.style.display = 'flex';
			}
		} else {
			// Normal stream available, show video
			fullscreenVideo.style.display = 'block';
			const fullscreenPlaceholder = document.getElementById('fullscreen-placeholder');
			if (fullscreenPlaceholder) {
				fullscreenPlaceholder.style.display = 'none';
			}
			
			// Set up fullscreen video
			try {
				fullscreenVideo.src = cam.url;
				fullscreenVideo.muted = false; // Enable audio in fullscreen mode as per FR-1.4
				fullscreenVideo.play().catch(e => {
					logMessage(`Fullscreen playback error: ${e.message}`);
				});
			} catch (error) {
				logMessage(`Error setting up fullscreen: ${error.message}`);
			}
		}
		
		fullscreenLabel.textContent = cam.name;
		fullscreenMode.style.display = 'block';
		isFullscreenMode = true;
		
		currentFocusedCam = camId;
		logMessage(`Now viewing: ${cam.name}`);
	}

	// Exit fullscreen mode
	function exitFullscreenMode() {
		const fullscreenMode = document.getElementById('fullscreen-mode');
		const fullscreenVideo = document.getElementById('fullscreen-video');
		
		// Stop video playback
		fullscreenVideo.pause();
		fullscreenVideo.src = "";
		
		fullscreenMode.style.display = 'none';
		isFullscreenMode = false;
	}

	// Cycle through cameras in fullscreen mode
	function cycleCameraFullscreen(direction) {
		const currentIndex = webcamConfig.findIndex(cam => cam.id === currentFocusedCam);
		let newIndex = (currentIndex + direction + webcamConfig.length) % webcamConfig.length;
		
		currentFocusedCam = webcamConfig[newIndex].id;
		enterFullscreenMode(currentFocusedCam);
	}

	// Display log message
	function logMessage(message) {
		const logBox = document.getElementById('log-box');
		logBox.textContent = message;
		logBox.classList.add('show');
		
		// Hide the log box after 3 seconds
		setTimeout(function() {
			logBox.classList.remove('show');
		}, 3000);
		
		console.log(`[WebcamApp] ${message}`);
	}
	
	// Show grid layout settings
	function showGridSettings() {
		settingsMode = 'grid';
		
		// Render grid settings UI
		const settingsContent = document.getElementById('settings-content');
		
		let content = `
			<div class="settings-section">
				<div class="settings-section-title">Grid Layout Settings</div>
				<div class="add-webcam-form">
					<div class="form-group">
						<label for="grid-type">Grid Layout Type</label>
						<select id="grid-type" class="form-control">
							<option value="auto" ${layoutSettings.autoLayout ? 'selected' : ''}>Auto (Dynamic)</option>
							<option value="2x2" ${!layoutSettings.autoLayout && layoutSettings.gridRows === 2 && layoutSettings.gridColumns === 2 ? 'selected' : ''}>2×2 Grid</option>
							<option value="3x3" ${!layoutSettings.autoLayout && layoutSettings.gridRows === 3 && layoutSettings.gridColumns === 3 ? 'selected' : ''}>3×3 Grid</option>
							<option value="custom" ${!layoutSettings.autoLayout && (layoutSettings.gridRows !== 2 && layoutSettings.gridRows !== 3 || layoutSettings.gridColumns !== 2 && layoutSettings.gridColumns !== 3) ? 'selected' : ''}>Custom Grid</option>
						</select>
					</div>
					
					<div id="custom-grid-options" class="form-group" style="${!layoutSettings.autoLayout && (layoutSettings.gridRows !== 2 && layoutSettings.gridRows !== 3 || layoutSettings.gridColumns !== 2 && layoutSettings.gridColumns !== 3) ? 'display:block;' : 'display:none;'}">
						<div style="display:flex; gap:15px;">
							<div style="flex:1;">
								<label for="grid-rows">Rows</label>
								<input type="number" id="grid-rows" class="form-control" min="1" max="4" value="${layoutSettings.gridRows}">
							</div>
							<div style="flex:1;">
								<label for="grid-columns">Columns</label>
								<input type="number" id="grid-columns" class="form-control" min="1" max="4" value="${layoutSettings.gridColumns}">
							</div>
						</div>
					</div>
					
					<div class="form-group">
						<label for="show-labels">
							<input type="checkbox" id="show-labels" ${layoutSettings.showLabels ? 'checked' : ''} style="width:auto; margin-right:10px;">
							Show camera labels
						</label>
					</div>
					
					<div class="form-group">
						<label for="refresh-interval">Auto-refresh Interval (seconds)</label>
						<input type="number" id="refresh-interval" class="form-control" min="0" max="300" value="${layoutSettings.refreshInterval}">
						<small style="color:#aaa;">0 = disabled, minimum 5 seconds if enabled</small>
					</div>
					
					<div class="form-buttons">
						<button id="cancel-grid-button" class="action-button" onclick="cancelGridSettings()">Cancel</button>
						<button id="save-grid-button" class="action-button" onclick="saveGridSettings()">Save</button>
					</div>
				</div>
			</div>
		`;
		
		settingsContent.innerHTML = content;
		
		// Add event listener for grid type changes
		setTimeout(() => {
			const gridType = document.getElementById('grid-type');
			if (gridType) {
				gridType.addEventListener('change', function() {
					const customOptions = document.getElementById('custom-grid-options');
					if (this.value === 'custom') {
						customOptions.style.display = 'block';
					} else {
						customOptions.style.display = 'none';
					}
				});
			}
			
			// Focus on grid type select
			focusSettingsElement('grid-type');
		}, 100);
	}
	
	// Cancel grid settings and return to list
	function cancelGridSettings() {
		settingsMode = 'list';
		renderSettingsContent();
		
		// Focus on the grid settings button
		setTimeout(() => {
			focusSettingsElement('grid-settings-button');
		}, 100);
	}
	
	// Save grid settings
	function saveGridSettings() {
		const gridType = document.getElementById('grid-type').value;
		const gridRows = parseInt(document.getElementById('grid-rows').value) || 2;
		const gridColumns = parseInt(document.getElementById('grid-columns').value) || 2;
		const showLabels = document.getElementById('show-labels').checked;
		const refreshInterval = parseInt(document.getElementById('refresh-interval').value) || 0;
		
		// Update layout settings based on grid type
		layoutSettings.showLabels = showLabels;
		layoutSettings.refreshInterval = Math.max(0, refreshInterval);
		
		if (gridType === 'auto') {
			layoutSettings.autoLayout = true;
		} else {
			layoutSettings.autoLayout = false;
			
			if (gridType === '2x2') {
				layoutSettings.gridRows = 2;
				layoutSettings.gridColumns = 2;
			} else if (gridType === '3x3') {
				layoutSettings.gridRows = 3;
				layoutSettings.gridColumns = 3;
			} else if (gridType === 'custom') {
				layoutSettings.gridRows = Math.min(4, Math.max(1, gridRows));
				layoutSettings.gridColumns = Math.min(4, Math.max(1, gridColumns));
			}
		}
		
		// Save settings
		try {
			localStorage.setItem('layoutSettings', JSON.stringify(layoutSettings));
			logMessage("Grid settings saved");
			
			// Return to list view
			settingsMode = 'list';
			renderSettingsContent();
			
			// Focus on the grid settings button
			setTimeout(() => {
				focusSettingsElement('grid-settings-button');
			}, 100);
			
			// Apply the new grid layout
			applyGridLayout();
		} catch (error) {
			logMessage("Error saving grid settings");
			console.error("Grid settings save error:", error);
		}
	}
	
	// Apply the current grid layout settings to the webcam grid
	function applyGridLayout() {
		const webcamGrid = document.getElementById('webcam-grid');
		const containers = document.querySelectorAll('.webcam-container');
		
		// Show/hide labels based on settings
		containers.forEach(container => {
			const label = container.querySelector('.webcam-label');
			if (label) {
				label.style.display = layoutSettings.showLabels ? 'block' : 'none';
			}
		});
		
		// Apply grid layout
		if (layoutSettings.autoLayout) {
			// Auto layout based on number of webcams
			const count = webcamConfig.length;
			let cols, rows;
			
			if (count <= 1) {
				cols = 1; rows = 1;
			} else if (count <= 2) {
				cols = 2; rows = 1;
			} else if (count <= 4) {
				cols = 2; rows = 2;
			} else if (count <= 6) {
				cols = 3; rows = 2;
			} else if (count <= 9) {
				cols = 3; rows = 3;
			} else {
				cols = 4; rows = Math.ceil(count / 4);
			}
			
			webcamGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
			webcamGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
		} else {
			// Manual layout
			webcamGrid.style.gridTemplateColumns = `repeat(${layoutSettings.gridColumns}, 1fr)`;
			webcamGrid.style.gridTemplateRows = `repeat(${layoutSettings.gridRows}, 1fr)`;
		}
		
		// Set up auto-refresh if enabled
		if (layoutSettings.refreshInterval > 0) {
			setupAutoRefresh();
		}
	}
	
	// Set up auto-refresh of webcam feeds
	let refreshInterval;
	function setupAutoRefresh() {
		// Clear any existing interval
		if (refreshInterval) {
			clearInterval(refreshInterval);
		}
		
		// Only set up interval if refresh is enabled
		if (layoutSettings.refreshInterval >= 5) {
			refreshInterval = setInterval(() => {
				refreshWebcamFeeds();
			}, layoutSettings.refreshInterval * 1000);
			
			logMessage(`Auto-refresh enabled (${layoutSettings.refreshInterval}s)`);
		}
	}
	
	// Refresh all webcam feeds
	function refreshWebcamFeeds() {
		const videos = document.querySelectorAll('.webcam-feed');
		videos.forEach(video => {
			// Store the current source
			const currentSrc = video.src;
			
			// Add a timestamp to force reload
			const timestamp = new Date().getTime();
			const newSrc = currentSrc.includes('?') 
				? `${currentSrc}&_t=${timestamp}` 
				: `${currentSrc}?_t=${timestamp}`;
			
			// Set the new source
			video.src = newSrc;
		});
		
		logMessage("Webcam feeds refreshed");
	}
	
	// Network connectivity monitoring
	function initNetworkMonitoring() {
		// Check initial network status
		updateNetworkStatus();
		
		// Set up event listeners for online/offline events
		window.addEventListener('online', () => {
			updateNetworkStatus();
			logMessage("Network connection restored");
			
			// Attempt to reload webcam feeds
			loadWebcams();
		});
		
		window.addEventListener('offline', () => {
			updateNetworkStatus();
			logMessage("Network connection lost");
		});
		
		// Periodically check network status
		setInterval(updateNetworkStatus, 30000); // Check every 30 seconds
	}
	
	// Update the network status indicator
	function updateNetworkStatus() {
		const online = navigator.onLine;
		networkStatus = online ? "online" : "offline";
		
		// Create or update network status indicator
		let statusIndicator = document.getElementById('network-status');
		if (!statusIndicator) {
			statusIndicator = document.createElement('div');
			statusIndicator.id = 'network-status';
			statusIndicator.className = online ? 'status-online' : 'status-offline';
			
			const indicator = document.createElement('span');
			indicator.className = 'status-indicator';
			
			const text = document.createElement('span');
			
			statusIndicator.appendChild(indicator);
			statusIndicator.appendChild(text);
			
			document.querySelector('.header-left').appendChild(statusIndicator);
		}
		
		// Update existing indicator
		statusIndicator.className = online ? 'status-online' : 'status-offline';
		const indicator = statusIndicator.querySelector('.status-indicator');
		if (indicator) {
			indicator.style.backgroundColor = online ? '#2ecc71' : '#e74c3c';
		}
		
		const text = statusIndicator.querySelector('span:not(.status-indicator)');
		if (text) {
			text.textContent = online ? 'Online' : 'Offline';
		}
		
		return online;
	}
</script>

<body>
	<!-- Splash Screen -->
	<div id="splash-screen" class="splash-screen">
		<div class="splash-logo">Webcam Viewer</div>
		<div class="splash-spinner"></div>
		<div id="splash-message" class="splash-message">Initializing...</div>
	</div>

	<div class="container">
		<header class="header">
			<div class="header-left">
				<div class="app-title">Webcam Viewer</div>
			</div>
			<div class="header-right">
				<button id="settings-button" class="settings-button" title="Settings">
					 ⚙️ Settings
				</button>
				<div class="clock" id="clock">--:--</div>
			</div>
		</header>
		
		<div class="webcam-grid" id="webcam-grid">
			<!-- Webcam containers will be dynamically inserted here -->
		</div>
		
		<div class="fullscreen-mode" id="fullscreen-mode">
			<video id="fullscreen-video" class="fullscreen-feed" autoplay playsinline></video>
			<div id="fullscreen-label" class="webcam-label"></div>
			<div class="navigation-hint">↑↓: Change Camera | ←: Back to Grid</div>
		</div>
		
		<!-- Settings Overlay -->
		<div id="settings-overlay" class="settings-overlay">
			<div class="settings-modal">
				<div class="settings-header">
					<div class="settings-title">Webcam Settings</div>
				</div>
				<div id="settings-content" class="settings-content">
					<!-- Content will be dynamically generated -->
				</div>
				<div class="settings-footer">
					<button id="close-settings" class="action-button" onclick="applySettings()">Apply & Close</button>
				</div>
			</div>
		</div>
		
		<div class="log-box" id="log-box">
			<!-- Log messages will appear here -->
		</div>
	</div>

	<!-- Settings Menu -->
	<div id="settings-menu" class="settings-menu hidden">
		<div class="settings-header">
			<h2>Settings</h2>
			<button id="settings-close" class="btn btn-close">X</button>
		</div>

		<!-- Settings List Mode -->
		<div id="settings-list-mode" class="settings-section">
			<h3>Webcam Settings</h3>
			<div class="webcam-list" id="settings-webcam-list"></div>
			<div class="settings-buttons">
				<button id="add-webcam-btn" class="btn">Add Webcam</button>
				<button id="edit-layout-btn" class="btn">Grid Layout</button>
				<button id="cancel-settings-btn" class="btn">Cancel</button>
			</div>
		</div>

		<!-- Add Webcam Mode -->
		<div id="settings-add-mode" class="settings-section hidden">
			<!-- ...existing code... -->
		</div>

		<!-- Edit Webcam Mode -->
		<div id="settings-edit-mode" class="settings-section hidden">
			<!-- ...existing code... -->
		</div>

		<!-- Grid Layout Mode -->
		<div id="settings-grid-layout-mode" class="settings-section hidden">
			<h3>Grid Layout Settings</h3>
			<div class="form-group">
				<label for="grid-type">Grid Type:</label>
				<select id="grid-type" class="form-control">
					<option value="auto">Auto (Dynamic)</option>
					<option value="2x2">2x2 Grid</option>
					<option value="3x3">3x3 Grid</option>
					<option value="custom">Custom Grid</option>
				</select>
			</div>
			<div class="form-group" id="custom-grid-options">
				<label for="grid-rows">Rows:</label>
				<input type="number" id="grid-rows" class="form-control" min="1" max="6" value="2">
				<label for="grid-columns">Columns:</label>
				<input type="number" id="grid-columns" class="form-control" min="1" max="6" value="2">
			</div>
			<div class="form-group">
				<label for="show-labels">Show Camera Labels:</label>
				<input type="checkbox" id="show-labels" checked>
			</div>
			<div class="form-group">
				<label for="auto-refresh">Auto-refresh Interval (seconds):</label>
				<input type="number" id="auto-refresh" class="form-control" min="0" max="300" value="0">
				<small>0 = disabled, min 5 seconds if enabled</small>
			</div>
			<div class="settings-buttons">
				<button id="save-layout-btn" class="btn">Save</button>
				<button id="cancel-layout-btn" class="btn">Cancel</button>
			</div>
		</div>
	</div>
</body>

</html>
